define([], function () {
function BaseSolver(Problem, Parameters) {
		
		//You can change the variable names, but these are parameters the user can set
		var n = Parameters["antParam1"];
		var stepSize = Parameters["antParam2"]; 
		var decayRate = Parameters["antParam3"];
		var pheromoneIntensity = Parameters["antParam4"];
		var size = Problem.getSolutionSize();
		console.log("Pop Size: " + n);
		var population = initAnts(n, size);

		var pheromoneDeposits = new Array();		
		var stepVec;
		var pheromone = new Array();		
		var nextStep = new Array();
		var bestSoln = population[0];
        var iterations = 0;
		//use this to get the score of your solution vector

		this.bestLength = Number.MAX_VALUE;

		for(var i = 0; i < n; i++) {
			// deposit pheromones and take initial first step
			pheromoneDeposits[i] = population[i].slice();
			pheromoneDeposits[i].push(pheromoneIntensity);
			stepVec = genDirection(size);
			stepVec = vecScale(stepVec, Math.random() * stepSize);
			population[i] = vecAdd(population[i], stepVec);

            /* Make sure too normalize the solution vector if the vecAdd *
             * operation made any values greater than 1.0                */
            for(var j = 0; j < size; j++) {
                if(population[i][j] > 1.0 || population[i][j] < 0.0) {
                    population[i] = normalize(population[i], 1);
                }
            }
		}
		this.step = function() {
			/*This is where you will write the bulk of your program, this is a "step", 
			and it is what you do each "turn" your algorithm has. Each algorithm
			has the same amount of time to perform as many steps as it pleases. */

			//return vector of weights (the best solution you have)
			for(i = 0; i < n; i++) {
				// find best next step and take it
				// deposit pheromones
				nextStep = getNextStep(population[i], stepSize, pheromoneDeposits, size); 
				pheromone = population[i].slice();
				pheromone.push(pheromoneIntensity);
				pheromoneDeposits.push(pheromone);
                if(population[i][0] > 1.0 || population[i][1] > 1.0 ||
                   population[i][0] < 0.0 || population[i][1] < 0.0) {
                    population[i] = normalize(population[i], 1);
                }
			}

			managePheromones(decayRate, pheromoneDeposits);	
	
			population = _.sortBy(population, function(ant){return Problem.getScore(ant);});
			var curBest = population[0];
			var curLength = Problem.getScore(curBest);
			if(curLength < this.bestLength){
				this.bestLength = curLength;
				bestSoln = curBest;	
			}

            /* Make sure too normalize the solution vectors if any of their *
             * values are not between 0.0 and 1.0.                          */
            for(var j = 0; j < n; j++) {
                for(var k = 0; k < size; k++) {
                    if(population[j][k] > 1.0 || population[j][k] < 0.0) {
                        population[j] = normalize(population[j], 1);
                    }
                }
            }
			this.bestLength = Problem.getScore(bestSoln);
            iterations++;
			return [bestSoln];
		}
}
/***********************************************************************************/
/********** I've provided you with some basic vector operation functions ***********/
/********************* If you have questions, feel free to ask *********************/
/***********************************************************************************/

function initAnts(n, size) {
	var ants = _.range(n);
	ants = _.map(ants, function(){
		return _.map(_.range(size), function() { 
			return Math.random();
			}); 
		});
	return ants;
}

function vecAdd(veca, vecb) {
	var sum = [];
	for(var i = 0; i < veca.length; i++){
		sum[i] = veca[i] + vecb[i];
	}
	return sum;
}

function vecDiff(veca, vecb) {
	var diff = [];
	for(var i = 0; i < veca.length; i++){
		diff[i] = veca[i] - vecb[i];
	}
	return diff;
}

function vecScale(veca, scalar) {
	var scaled = [];
	for(var i = 0; i < veca.length; i++){
		scaled[i] = veca[i] * scalar;
	}
	return scaled;
}

//Clamps the weights to all being between 0 and 1. Do this before you 
//return your vector, the scoring function likes it like that. 
function vecClamp(vector){
	var clamped = [];
	for(var i = 0; i < vector.length; i++){
		if(vector[i] > 1)
			clamped[i] = 1;
		else if(vector[i] < 0)
			clamped[i] = 0;
		else
			clamped[i] = vector[i];
	}
	return clamped;
}

function genDirection(size) {
	var direction = [];
	for(var i = 0; i < size; i++) {
        direction[i] = Math.random(-1, 1);
	}
	direction = normalize(direction, 1);
	return direction; 
}

function getMagnitude(vector) {
	var magnitude = 0;
	for(var i = 0; i < vector.length; i++) {
		magnitude += Math.pow(vector[i], 2);
	}
	magnitude = Math.sqrt(magnitude)
		return magnitude;
}

function normalize(vector, radius) {
	var magnitude = getMagnitude(vector);
	for(var i = 0; i < vector.length; i++) {
		vector[i] = (vector[i] * radius) / magnitude;
	}
	return vector;
}

function getDistance(veca, vecb) {
	var dist = 0;
	for(var i = 0; i < vecb.length; i++) {
		dist += Math.pow((vecb[i] - veca[i]), 2); 
	}
	dist = Math.sqrt(dist);
	return dist
}

function erf(x) {

	var a1 = 0.254829592
	var a2 = -0.284496736
	var a3 = 1.421413741
	var a4 = -1.453152027
	var a5 = 1.061405429
	var p = 0.3275911

	t = 1 / (1 + p * x);
	var result = 1 - ((a1 * t) + (a2 * Math.pow(t, 2)) + (a3 * Math.pow(t, 3)) + (a4 * Math.pow(t, 4)) + (a5 * Math.pow(t, 5))) * (1 / Math.pow(Math.E, Math.pow(x, 2)));
	return result;
}

function normsDist(z) {
	var lbound = -Number.MAX_NUMBER;
	var err1 = erf(z / Math.sqrt(2));
	var err2 = erf(lbound / Math.sqrt(2));
	
	var result = err1 - err2;
	return result;
}

function managePheromones(decayRate, deposits) {
	var p;
	for(var i = 0; i < deposits.length; i++) {
		p = deposits[i].pop();
		p -= decayRate;
		deposits[i].push(p);
	}
	for(i = 0; i < deposits.length; i++) {
		if(_.last(deposits[i]) < 0) {
			deposits.splice(i, 1);
		}		
	}
}

function getNextStep(ant, R, pheromones, size) {
	var baseStepLen = size;
	var i = + 0;
	var currTarget = vecDiff(ant, ant);						// TODO: tha fuck
//	console.log("VecDiff(ant, ant) = " + currTarget);
	var nextTarget = new Array();
	var Pc; //Probability current is taken
	var Pn; //Probability next is taken
	for(i = 0; i < 100; i++) {
		if(Math.random() > 0.5) {
			// adjust dist
			nextTarget = vecScale(currTarget, Math.random() * R);
//			console.log("NextTarget = " + nextTarget);
			if(stepCheck(vecAdd(currTarget, ant), vecAdd(nextTarget, ant), pheromones) == 1) {
				currTarget = nextTarget;
			} else {
				// just stay where you are
			}
		} else {
			// adjust angle
			nextTarget = randomStep(currTarget, ant, R, baseStepLen);
			if(stepCheck(vecAdd(currTarget, ant), vecAdd(currTarget, ant), pheromones) == 1) {
				// take the step!
				currTarget = nextTarget;
			}
						
		}
		
	}
}

function randomStep(curr, R, stepSize, size) {
	var stepVec = genDirection(size);
	stepVec = vecScale(stepVec, Math.random() * stepSize);
	stepVec = vecAdd(curr, stepVec);
	normalize(stepVec, R);	
}

function stepCheck(curr, next, pheromones) {
	var Pc = + 0;
	var Pn = + 0;
	var ratio = 0;	

	for(var i = 0; i < pheromones.length; i++) {
		Pc += normsDist(getDistance(pheromones[i], curr));
		Pn += normsDist(getDistance(pheromones[i], next));
	}
	ratio = Pn / Pc;
	if(ratio >= 1) {
		return 1;
	} else {
		if(Math.random() < ratio) {
			return 1;
		} else {
			return 0;
		}
	}	
}

return {Solver: BaseSolver, Params: [           

//These are user-editable parameters
//feel free to change the name and starting values of them
//also feel free to add as many as you feel you need. 
{"name": "Number of Ants",
	"id" : "antParam1",
	"type": "int",
	"value": 19},
{"name": "Step Size",
	"id" : "antParam2", 
	"type": "float",   
	"value": 0.73}, 
{"name": "Decay Rate",
	"id" : "antParam3",
	"type": "float",
	"value": 2.0},    
{"name": "Pheromone Intensity",
	"id" : "antParam4",       
	"type": "float",
	"value": 0.45},            
]
};

});
