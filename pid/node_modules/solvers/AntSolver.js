define([], function () {
function BaseSolver(Problem, Parameters) {
		
		//You can change the variable names, but these are parameters the user can set
		var n = Parameters["antParam1"];
		var stepSize = Parameters["antParam2"]; 
		var decayRate = Parameters["antParam3"];
		var pheromoneIntensity = Parameters["antParam4"];
		var size = Problem.getSolutionSize();
		console.log("Pop Size: " + n);
		var population = initAnts(n, size);

		var pheromoneDeposits = new Array();		
		var stepVec;
		var pheromone = new Array();		
		var nextStep = new Array();
		var bestSoln = population[0];
        var iterations = 0;
		//use this to get the score of your solution vector

		this.bestLength = Number.MAX_VALUE;

		for(var i = 0; i < n; i++) {
			// deposit pheromones and take initial first step
			pheromoneDeposits[i] = population[i].slice();
			pheromoneDeposits[i].push(pheromoneIntensity);
			stepVec = genDirection(size);
			stepVec = vecScale(stepVec, Math.random() * stepSize);
			population[i] = vecAdd(population[i], stepVec);

            /* Make sure too normalize the solution vector if the vecAdd *
             * operation made any values greater than 1.0                */
            for(var j = 0; j < size; j++) {
                if(population[i][j] > 1.0 || population[i][j] < 0.0) {
                    population[i] = normalize(population[i], 1);
                }
            }
		}
		this.step = function() {
			/*This is where you will write the bulk of your program, this is a "step", 
			and it is what you do each "turn" your algorithm has. Each algorithm
			has the same amount of time to perform as many steps as it pleases. */

			//return vector of weights (the best solution you have)
			for(i = 0; i < n; i++) {
				// find best next step and take it
				// deposit pheromones
				nextStep = getNextStep(population[i], stepSize, pheromoneDeposits, size, Problem);
				population[i] = nextStep;
				if(Problem.getScore(nextStep) < Problem.getScore(population[i])) {
					console.log("updating current population: " + i);
					pheromone = population[i].slice();
					pheromone.push(pheromoneIntensity);
					pheromoneDeposits[i] = pheromone;
					if(population[i][0] > 1.0 || population[i][1] > 1.0 ||
						population[i][0] < 0.0 || population[i][1] < 0.0) {
						console.log("normalizing population: " + i);
						population[i] = normalize(population[i], 1);
					}
				}
			}
//			managePheromones(decayRate, pheromoneDeposits);	
//			console.log("pheromoneDeposits Length After: " + pheromoneDeposits.length);
	
			population = _.sortBy(population, function(ant){return Problem.getScore(ant);});
			var curBest = population[0];
			var curLength = Problem.getScore(curBest);
			if(curLength < this.bestLength){
				this.bestLength = curLength;
				bestSoln = curBest;	
			}

            /* Make sure too normalize the solution vectors if any of their *
             * values are not between 0.0 and 1.0.                          */
            for(var j = 0; j < n; j++) {
                for(var k = 0; k < size; k++) {
                    if(population[j][k] > 1.0 || population[j][k] < 0.0) {
                        population[j] = normalize(population[j], 1);
                    }
                }
            }
			this.bestLength = Problem.getScore(bestSoln);
            iterations++;
			console.log("bestScore: " + this.bestLength + "\tcurBest: " + curLength);
			return [bestSoln];
		}
}
/***********************************************************************************/
/********** I've provided you with some basic vector operation functions ***********/
/********************* If you have questions, feel free to ask *********************/
/***********************************************************************************/

function initAnts(n, size) {
	var ants = _.range(n);
	ants = _.map(ants, function(){
		return _.map(_.range(size), function() { 
			return Math.random();
			}); 
		});
	return ants;
}

function vecAdd(veca, vecb) {
	var sum = [];
	for(var i = 0; i < veca.length; i++){
		sum[i] = veca[i] + vecb[i];
	}
	return sum;
}

function vecDiff(veca, vecb) {
	var diff = [];
	for(var i = 0; i < veca.length; i++){
		diff[i] = veca[i] - vecb[i];
	}
	return diff;
}

function vecScale(veca, scalar) {
	var scaled = [];
	for(var i = 0; i < veca.length; i++){
		scaled[i] = veca[i] * scalar;
	}
	return scaled;
}

//Clamps the weights to all being between 0 and 1. Do this before you 
//return your vector, the scoring function likes it like that. 
function vecClamp(vector){
	var clamped = [];
	for(var i = 0; i < vector.length; i++){
		if(vector[i] > 1)
			clamped[i] = 1;
		else if(vector[i] < 0)
			clamped[i] = 0;
		else
			clamped[i] = vector[i];
	}
	return clamped;
}

function genDirection(size) {
	var direction = [];
	for(var i = 0; i < size; i++) {
        direction[i] = Math.random(-1, 1);
	}
	direction = normalize(direction, 1);
	return direction; 
}

function getMagnitude(vector) {
	var magnitude = 0;
	for(var i = 0; i < vector.length; i++) {
		magnitude += Math.pow(vector[i], 2);
	}
	magnitude = Math.sqrt(magnitude)
		return magnitude;
}

function normalize(vector, radius) {
	var magnitude = getMagnitude(vector);
	for(var i = 0; i < vector.length; i++) {
		vector[i] = (vector[i] * radius) / magnitude;
	}
	return vector;
}

function managePheromones(decayRate, deposits) {
	var p;
	for(var i = 0; i < deposits.length; i++) {
		p = deposits[i].pop();
		p -= decayRate;
		console.log("P: " + p);
		deposits[i].push(p);
	}
	for(i = 0; i < deposits.length; i++) {
		if(_.last(deposits[i]) < 0) {
			deposits.splice(i, 1);
		}		
	}
}

function getNextStep(ant, R, pheromones, size, Problem) {
	var baseStepLen = size;
	var i = + 0;
	var currTarget = ant;
	var nextTarget1 = new Array();
	var nextTarget2 = new Array();

	nextTarget1 = vecScale(currTarget, R);
	nextTarget2 = randomStep(currTarget, ant, R, baseStepLen);

	if(Problem.getScore(nextTarget1) <  Problem.getScore(currTarget)) {
		currTarget = nextTarget1;
		console.log("Updated currTarget to 1: " + Problem.getScore(currTarget));
	}
	if(Problem.getScore(nextTarget2) <  Problem.getScore(currTarget)) {
		currTarget = nextTarget2;
		console.log("Updated currTarget to 2: " + Problem.getScore(currTarget));
	}
	return currTarget;
}

function randomStep(curr, R, stepSize, size) {
	var stepVec = genDirection(size);
	stepVec = vecScale(stepVec, Math.random() * stepSize);
	stepVec = vecAdd(curr, stepVec);
	test = normalize(stepVec, 1);
	return test;	
}

return {Solver: BaseSolver, Params: [           

//These are user-editable parameters
//feel free to change the name and starting values of them
//also feel free to add as many as you feel you need. 
{"name": "Number of Ants",
	"id" : "antParam1",
	"type": "int",
	"value": 19},
{"name": "Step Size",
	"id" : "antParam2", 
	"type": "float",   
	"value": 0.73}, 
{"name": "Decay Rate",
	"id" : "antParam3",
	"type": "float",
	"value": 2.0},    
{"name": "Pheromone Intensity",
	"id" : "antParam4",       
	"type": "float",
	"value": 0.45},            
]
};

});
