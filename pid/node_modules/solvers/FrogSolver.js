define([], function (){
	function FrogSolver(Problem, Parameters){
		var Problem = Problem;
		this.solnSize = Problem.getSolutionSize();
		this.numFrogs = Parameters["FrogParam1"];
		this.numMemePlexes = Parameters["FrogParam2"];
		this.mutPerGen = Parameters["FrogParam3"];
		//if(this.numFrogs % this.numMemePlexes != 0){
		//	window.alert("Frogs must be divisible by the number of divisions");
		//	return;
		//}
		var frogs = InitFrogs(this.numFrogs, this.solnSize);
		frogs = _.sortBy(frogs, function(frog){return Problem.getScore(frog);});
		this.bestLength = Problem.getScore(frogs[0]);
		this.bestFrog = frogs[0].slice(0);
		this.dividedFrogs = divideFrogs(this.numMemePlexes, frogs);

		this.step = function(){
			for(var i = 0; i < this.numMemePlexes; ++i){
				for (var j = 0; j < this.mutPerGen; ++j){
					//Get Fitness of Current MemePlex
					this.dividedFrogs[i] = _.sortBy(this.dividedFrogs[i], function(frog){return Problem.getScore(frog);});
					var best = this.dividedFrogs[i].length-1; 
					var worst = 0;
					var newFrog = GenerateFrog(this.dividedFrogs[i][best], this.dividedFrogs[i][worst]);
					var tempWorstTrail = this.dividedFrogs[i][worst];
					var tempDist = Problem.getScore(newFrog);
					// If its a new global best, replace it
					if(tempDist < this.bestLength){
						this.dividedFrogs[i][worst] = newFrog;
						this.bestLength = tempDist;
						this.bestFrog = newFrog.slice(0); 
					}
					else if(tempDist < Problem.getScore(tempWorstTrail)){
						this.dividedFrogs[i][worst] = newFrog;
					}
					else{ // repeat above steps but using global best
						newFrog = GenerateFrog(this.bestFrog, this.dividedFrogs[i][worst]);
						var tempDist = Problem.getScore(newFrog);
						// If its a new global best, replace it
						if(tempDist < this.bestLength){
							this.dividedFrogs[i][worst] = newFrog;
							this.bestLength = tempDist;
							this.bestFrog = newFrog.slice(0);
						}
						else if(tempDist < Problem.getScore(tempWorstTrail)){
							this.dividedFrogs[i][worst] = newFrog;
						}
					}
				}
			}
			ShuffleMemPlexes(this.dividedFrogs);
			return [this.bestFrog];
		}
	}

	function GenerateFrog(best, worst, numMutation){
		var subt = new Array(best.length);
		var rand = Math.random() * 2 - 1; //[-1, 1]
		for(var k = 0; k < best.length; ++k){
			subt[k] = best[k] - worst[k]; 
			subt[k] = subt[k] * rand;
			subt[k] = +worst[k] + subt[k]
		}
		return subt;
	}

	function ShuffleMemPlexes(frogArr){
		var single = new Array(frogArr.length * frogArr[0].length);
		var count = 0;
		for (var i = 0; i < frogArr.length; ++i) 
			for(var j = 0; j < frogArr[0].length; ++j){
				single[count] = frogArr[i][j];
			}

		for (var i = 0; i < single.length; ++i) // Fisher-Yates shuffle
		{
			var r = Math.floor(Math.random() * single.length);
			var tmp = single[r]; single[r] = single[i]; single[i] = tmp;
		}

		return divideFrogs(frogArr.length, single);
	}

	function divideFrogs(numDivisions, frogs){
		// numDivisions must divide frogs
		// allocate memory for frogs
		var numPerDivision = Math.floor(frogs.length / numDivisions);
		var frogArr = new Array(numDivisions);
		for(var i = 0; i < numDivisions; ++i){
			frogArr[i] = new Array(numPerDivision);
		}
		// Assign frogs to respective area
		for(var i = 0; i < numDivisions; ++i){
			for(var j = 0; j < numPerDivision; ++j){
				frogArr[i][j] = frogs[i];		
			}
		}
		return frogArr;
	}

	function InitFrogs(n, size){
		var flock = _.range(n);
		flock = _.map(flock, function(){
			return _.map(_.range(size), function() { 
				return Math.random();
			}); 
		});
		return flock;
	}

	return {Solver: FrogSolver, Params: [ {"name": "Number of Frogs",
		"id" : "FrogParam1",
		"type": "int",
		"value": 13},
		{"name": "Number of Memory Plexes",
			"id" : "FrogParam2",
			"type": "int",
			"value": 4},
		{"name": "Number of Mutations per Generation",
			"id" : "FrogParam3",
			"type": "int",
			"value": 2}
	]};

});
