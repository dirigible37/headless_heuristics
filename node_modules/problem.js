if (typeof define !== 'function') { var define = require('amdefine')(module) }

define([], function () {
	var distance = function (pointA, pointB) {
		return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) +
			Math.pow(pointA.y - pointB.y, 2));
	};


	var TSPProblem = function(completeGraph) {
		this.graph = completeGraph;

		this.getScore = function(solution) {
			// Sort indexed solution by score
			var sorted = _.sortBy(_.range(solution.length), function (index) {
				return solution[index];
			});

			var first_point = this.graph.vertices[sorted[sorted.length-1]];
			// TODO Is this wrong? Ignores weight for first city
			var current_point;
			var next_point = first_point;

			// Walk the vertices, decending solution score order
			var score = 0;
			for (var i = sorted.length - 2; i >= 0; i--) {
				var next_index = sorted[i];

				current_point = next_point;
				next_point = this.graph.vertices[next_index];

				score += distance(current_point, next_point);
			}
			// Compute the distance back to the initial point
			score += distance(next_point, first_point);
			return score;
		};

		this.getSolutionSize = function() {
			return this.graph.vertices.length;
		};

		this.weightedSolutionToTrail = weightedSolutionToTrail;
		this.trailToWeightedSolution = trailToWeightedSolution;
	};


	var generateRandomTSPProblem = function(solutionSize) {
		var numVertices = solutionSize;

		var nGraph = {};
		nGraph.vertices = [];

		for (var i = 0; i < numVertices; i++) {
			var nPoint = {
				x: Math.random(),
				y: Math.random()
			};
			nGraph.vertices.push(nPoint);
		}
		return new TSPProblem(nGraph);
	};


	/* Converts a weightedSolution (the style needed by a problem object) into
	 * an array of indices. These indices are the ordered list of cities to
	 * visit in the graph.
	 */
	var weightedSolutionToTrail = function(weightedSolution) {
		return _.sortBy(_.range(weightedSolution.length), function (index) {
			return weightedSolution[index];
		}).reverse();
	};


	/* Converts a list of indices of cities to visit for a tour into a
	 * a weighted style solution (as problem objects expect)
	 */
	var trailToWeightedSolution = function(trail) {
		var stepLen = 1 / trail.length;
		var curr = 1;

		var weighted = _.range(trail.length);

		_.each(trail, function(index) {
			weighted[index] = curr;
			curr -= stepLen;
		});

		return weighted;
	};


	function processParams(solution, params, tunee, ranges) {
		var paramMin, paramMax, curSoln;
		var paramDef = tunee.Params;
		for(var i = 0; i < params.length; i++){
			//TODO: Work with headless
			paramMin = Number(ranges[i].min);
			paramMax = Number(ranges[i].max);
			curSoln = Math.abs(Number(solution[i].toFixed(2)));
			//This tunes the parameter
			paramID = paramDef[i]["id"];
			if(paramDef[i]["type"] == "float")
				params[paramID] = paramMin + ((paramMax - paramMin) * curSoln);
			else 
				params[paramID] = Math.floor(paramMin + ((paramMax - paramMin) * curSoln));
		}
		return params;
	}
	
	var count = 0;

	function runSolver(solver, timeCap) {
		var start, elapsed;
		var runTime = 0;
		var curScore = 0;
		var bestScore = Number.MAX_VALUE;

		do {
			start = new Date().getTime();
			solver.step();
			curScore = parseFloat(solver.bestLength).toFixed(4);
			
			if(curScore < bestScore)
				bestScore = curScore;
			elapsed = new Date().getTime() - start;
			runTime += elapsed;
		}while(runTime < timeCap);
		return bestScore;
	}

	function getMagnitude(vector) {
		var magnitude = 0;
		for(var i = 0; i < vector.length; i++) {
			magnitude += Math.pow(vector[i], 2);
		}
		magnitude = Math.sqrt(magnitude)
			return magnitude;
	}

	function normalize(vector) {
		var magnitude = getMagnitude(vector);
		for(var i = 0; i < vector.length; i++) {
			vector[i] = vector[i] / magnitude;
		}
		return vector;
	}

	var TunerProblem = function(numParams, tunee, problem, param_ranges, time_cap) {
		var params = _.range(numParams);

		this.getScore = function(solution) {
			solution = normalize(solution);
			params = processParams(solution, params, tunee, param_ranges);	
			//TODO: Make dynamic
			var iters = 20;
			var solver = new tunee.Solver(problem, params);
			var avg = Number(0);
			for(var i = 0; i < iters; i++){
				avg += Number(runSolver(solver, time_cap));
			}
			avg /= iters;
			//console.log(avg);
			return avg;
		}

		this.getSolutionSize = function() {
			return numParams;
		}
	};

	var generateTuneProblem = function(numParams, tunee, problem, param_ranges, time_cap) {
		return new TunerProblem(numParams, tunee, problem, param_ranges, time_cap);
	};
	
	var Easom = function() {
		this.getScore = function(solution) {
			normalize(solution);
			var bestScore = -1;
			var min = -100;
			var range = Math.abs(min*2);
			var x = min + (range*solution[0]);
			var y = min + (range*solution[1]);
			var soln = -1 * (Math.cos(x)) * (Math.cos(y));
			soln *= Math.exp(-1 * (Math.pow((x-Math.PI),2) + Math.pow((y-Math.PI),2)));
			
			soln += (-bestScore);
			return soln;
		}

		this.getSolutionSize = function() {
			return 2;
		}
	};

	var EggHolder = function() {
		this.getScore = function(_solution) {
			var solution = _solution.slice(0);
			//normalize(solution);
			var bestScore = -959.6407;
			var min = -512;
			var range = Math.abs(min*2);
			var x = min + (range*solution[0]);
			var y = min + (range*solution[1]);
			var soln = -1 * ((y+47) * Math.sin(Math.sqrt(Math.abs(y + (x/2) + 47))));
			soln -= x * (Math.sin(Math.sqrt(Math.abs(x - (y+47)))));
			
			soln += bestScore;
			return soln;
		}

		this.getSolutionSize = function() {
			return 2;
		}
	};

	var Ackley = function() {
		this.getScore = function(_solution) {
			//Range is -4.5 to 4.5
			var solution = _solution.slice(0);
			if(x < -1.0 || x > 1.0 || y < -1.0 || y > 1.0)
				solution = normalize(solution);
			var x = (solution[0]*64)-32;	
			var y = (solution[1]*64)-32;	
			//x = 30.135;
			//y = 29.8823;

			var soln = -20 * Math.exp(-0.2*Math.sqrt(0.5*((x*x) + (y*y))));
			soln -= Math.exp(0.5*(Math.cos(2*Math.PI*x)+Math.cos(2*Math.PI*y)));
			soln += Math.exp(1) + 20;

			return soln;
		}

		this.getSolutionSize = function() {
			return 2;
		}
		
		this.getLatency = function() {
			return 0;
		}
	};
	
	var Beale = function() {
		this.getScore = function(solution) {
			//Range is -4.5 to 4.5
			var min = -4.5;
			var range = Math.abs(min*2);
			var x = min + (range*solution[0]);
			var y = min + (range*solution[1]);
			var soln = Math.pow((1.5 - x + (x*y)),2);
			soln += Math.pow((2.25 - x + (x*Math.pow(y, 2))),2);
			soln += Math.pow((2.625 - x + (x*Math.pow(y,3))),2);
			return soln;
		}

		this.getSolutionSize = function() {
			return 2;
		}
	};

	var PID = function() {
		this.getScore = function(solution) {
			//http://node-0.bioinspired.cloudrobotics-pg0.clemson.cloudlab.us/error?data=20%20.02%203%200%20-3%20-10%200%20.9
			var xmlHttp = new XMLHttpRequest();
			var url = "http://node-0.bioinspired.cloudrobotics-pg0.clemson.cloudlab.us/error?data=20 .02 "+solution[0]+" "+solution[1]+" "+solution[2]+" "+solution[3]+" "+solution[4]+" "+solution[5]; 

			xmlHttp.open("get", theUrl, true);
			xmlHttp.send(null);
			return xmlHttp.responseText;
		}

		this.getSolutionSize = function() {
			return 6;
		}
	};

	var generateFunctionProblem = function(func) {
		var retFunc;
		switch(func) {
			case "pid":
				retFunc = new PID();
				break;
			case "beale":
				retFunc = new Beale();
				break;
			case "eggholder":
				retFunc = new EggHolder();
				break;
			case "easom":
				retFunc = new Easom();
				break;
			case "ackley":
				retFunc = new Ackley();
				break;
			default:
				break;
		}
		return retFunc;
	};

	return {
			generateFunctionProblem: generateFunctionProblem,
			generateRandomTSPProblem: generateRandomTSPProblem,
			generateTuneProblem: generateTuneProblem,
			weightedSolutionToTrail: weightedSolutionToTrail,
			trailToWeightedSolution: trailToWeightedSolution
	};
});
