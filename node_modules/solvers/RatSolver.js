define([], function () {
function RatSolver(Problem, Parameters) {
		
		var popSize = Math.floor(Parameters["ratParam6"]);	
		var problemSize = Problem.getSolutionSize();
		var tooClose = Parameters["ratParam1"];		
		var needToExplore = Parameters["ratParam2"];	//the want to continue the way its going	
		var aversionLevel = Parameters["ratParam3"];	//level of aversion to bad stimuli (bad solutions)
		var motorActivity = Parameters["ratParam4"];	//the want to move somewhere known
		var alphaLevel = Parameters["ratParam5"];	//the want to follow the alpha rat
		var crossoverRate = Parameters["ratParam7"];	//should be a float value between 0.0-1.0
		var numberOfChildren = Math.floor(popSize * .2);		//number of children to be made at the end of each step
		
		var ratPos = InitRats(popSize, problemSize);
		var ratVel = InitRats(popSize, problemSize);
		var ratPos = _.sortBy(ratPos, function(rat){return Problem.getScore(rat);});
		var ratScores = _.map(ratPos, function(rat){return Problem.getScore(rat);});
		var bestMemory = ratPos.slice();			//create array holding the best solution for each rat
		var worstMemory = ratPos.slice();			//create array holding the worst solution for each rat
		var goToBestMemory = 5;					//number of steps before rat tries to go back to best solution
		var goAwayWorstMemory = 10;
		var goToBestMemoryIndex = new Array(popSize);
		var goAwayWorstMemoryIndex = new Array(popSize);
			for(var i = 0; i < popSize; i++) {
				goToBestMemoryIndex[i] = 0;
				goAwayWorstMemoryIndex[i] = 0;
			}
		var alpha = ratPos[0].slice();
		var isAlpha = 0;
		var curBestLength;
		var totalBestSoln = alpha;

		this.bestLength = Number.MAX_VALUE;

		this.step = function() {
	
			for(var i = 0; i < popSize; i++) {		
			    if(ratScores[i] < Problem.getScore(alpha)) {	//update aplpha 
				alpha = ratPos[i].slice();
				isAlpha = i;
				//console.log("changing alpha");
			    }
			    if(ratScores[i] > Problem.getScore(worstMemory[i])) {	//if the current solution is worse
				worstMemory[i] = ratPos[i].slice();		        //than the worst, update Memory[0]
				goAwayWorstMemoryIndex[i] = 0;
				//console.log("updating worst Memory");
			    }
			    if(ratScores[i] < Problem.getScore(bestMemory[i])) {    //if current solution is better than the best
				bestMemory[i] = ratPos[i].slice();			//update personal best soltuion in Memory[1]
				goToBestMemoryIndex[i] = 0;
				//console.log("updating best Memory");
			    }
			    if(goAwayWorstMemoryIndex[i] > goAwayWorstMemory) {
			    	if(isTooClose(worstMemory[i], ratPos[i], tooClose)) {
				    //console.log("too close");
				    ratPos[i] = vecDiff(ratPos[i], vecScale(ratVel[i], aversionLevel * Math.random()));	//consider scaling ratPos by avLev instead
				    goAwayWorstMemoryIndex[i] = 0;
			        }		
			    }
			    if(i != isAlpha) {
				ratPos[i] = vecAdd(vecAdd(vecScale(alpha, alphaLevel), ratPos[i]), vecScale(ratVel[i], Math.random()));	//scale alpha, diff by ratPos, then add to ratVel
			    }
			    ratPos[i] = vecAdd(vecScale(ratVel[i], needToExplore), vecScale(ratPos[i], Math.random()));		//scale ratVel by its needToExplore
			    if(goToBestMemoryIndex[i] > goToBestMemory) {
			    	ratVel[i] = vecAdd(vecScale(vecDiff(bestMemory[i], ratPos[i]), motorActivity), ratVel[i]);	//diff rats best with current pos then scale by motor and add to ratVel
			    }
			    curBestLength = Problem.getScore(alpha);
			    if(curBestLength < this.bestLength) {
			      //console.log("updating bestLength and bestSoln");
			      this.bestLength = Problem.getScore(alpha);
			      totalBestSoln = alpha;
			    }
			    goToBestMemoryIndex[i]++;
			    goAwayWorstMemoryIndex[i]++;
			    ratScores[i] = Problem.getScore(ratPos[i]);
			}
			for(var i = 0; i < numberOfChildren; i++) {
			    var index = Math.floor(Math.random() * popSize);
			    var alphaMate = ratPos[index].slice();
			    var Children = mate(alpha, alphaMate, crossoverRate);
				
			    if(Problem.getScore(Children[0]) < Problem.getScore(Children[1])) {
				//console.log("child 1 survives");
				ratPos[index] = Children[0].slice();
				ratScores[index] = Problem.getScore(ratPos[index]);
			    } else {
				//console.log("child 2 survives");
				ratPos[index] = Children[1].slice();
				ratScores[index] = Problem.getScore(ratPos[index]);
			    }
			}
			this.bestLength = Problem.getScore(totalBestSoln);		
			return [normalize(totalBestSoln)];	
		}
}
function mate(alpha, alphaMate, crossOver) {
	
	var ratLength = alpha.length;
	var index1 = Math.floor(crossOver * ratLength);
	var index2 = ratLength - index1;
	var child1 = new Array(ratLength);
	var child2 = new Array(ratLength);
	var children = new Array(2);
	
	/* make child one by first taking from alpha, and then alphaMate */
	for(var i = 0; i < index1; i++) {
		child1[i] = alpha[i];
	}
	for(var j = index1; j < ratLength; j++) {
		child1[j] = alphaMate[j];
	}

	/* make child two by first taking from alphaMate, and then alpha */
	for(var k = 0; k < index2; k++) {
		child2[k] = alphaMate[k];
	}
	for(var l = index2; l < ratLength; l++) {
		child2[l] = alpha[l];
	}
	
	children[0] = child1.slice();
	children[1] = child2.slice();
	return children
}

function isTooClose(memory, rat, tooClose) {
	var dist = 0, retBool = false;
	var diff = [];
	diff = vecDiff(memory, rat);
	for(var i = 0; i < rat.length; i++) {
		diff[i] *= diff[i];
		dist += diff[i];
	}
	dist = Math.sqrt(dist);
	if(dist < tooClose)
		retBool = true;

	return retBool;
}

function normalize(vector) {
        var norm = [];
        var sum = 0;
        for(var i = 0; i < vector.length; i++) {
                sum += vector[i];
        }
        sum = 1/sum;
        norm = vecScale(vector, sum);
        return norm;
}

function vecAdd(veca, vecb) {
        var sum = [];
        for(var i = 0; i < veca.length; i++){
                sum[i] = veca[i] + vecb[i];
        }
        return sum;
}

function vecDiff(veca, vecb) {
        var diff = [];
        for(var i = 0; i < veca.length; i++){
                diff[i] = veca[i] - vecb[i];
        }
        return diff;
}

function vecScale(veca, scalar) {
        var scaled = [];
        for(var i = 0; i < veca.length; i++){
                scaled[i] = veca[i] * scalar;
        }
        return scaled;
}

function vecClamp(vector){
        var clamped = [];
        for(var i = 0; i < vector.length; i++){
                if(vector[i] > 1)
                        clamped[i] = 1;
                else if(vector[i] < 0)
                        clamped[i] = 0;
                else
                        clamped[i] = vector[i];
        }
        return clamped;
}

function InitRats(popSize, problemSize) {
	//console.log("Initializing Rats");
	var herd = _.range(popSize + 1);
	herd = _.map(herd, function() {
		return _.map(_.range(problemSize), function() {
			return Math.random();
			});
		});
	return herd;
}

return {Solver: RatSolver, Params: [
{"name": "Too Close",
	"id" : "ratParam1",
	"type": "float",
	"value": 0.53},
{"name": "Need for Exploration",
	"id" : "ratParam2",
	"type": "float",
	"value": 1.44},
{"name": "Aversion to Repulsive Stimuli",
	"id" : "ratParam3",
	"type": "float",
	"value": .33},
{"name": "Spontaneous Motor Activity",
	"id" : "ratParam4",
	"type": "float",
	"value": .65},
{"name": "Alpha Level",
        "id" : "ratParam5",
        "type": "float",
        "value": .12},
{"name": "Population Size",
        "id" : "ratParam6",
        "type": "int",
        "value": 10},
{"name": "Crossover Rate",
	"id" : "ratParam7",
	"type": "float",
	"value": .62},
]
};

});
