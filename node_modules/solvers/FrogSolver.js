define([], function (){
function FrogSolver(Problem, Parameters){
	this.Problem = Problem;
	this.solnSize = Problem.getSolutionSize();
	this.numFrogs = Parameters["FrogParam1"];
	this.mutPerGen = Parameters["FrogParam3"];
	this.numMemePlexes = Parameters["FrogParam2"];
	//if(this.numFrogs % this.numMemePlexes != 0){
	//	window.alert("Frogs must be divisible by the number of divisions");
	//	return;
	//}
	this.bound = Parameters["FrogParam4"];
	var frogs = InitFrogs(this.numFrogs, this.solnSize, this.bound);
	var fitness = Fitness(frogs, this.Problem);;
	var bestInd = GetBestFitness(fitness);
	this.bestLength = fitness[bestInd];
	this.bestFrog = frogs[bestInd].slice(0);
	this.dividedFrogs = divideFrogs(this.numMemePlexes, frogs);
}

FrogSolver.prototype.step = function(){
		for(var i = 0; i < this.numMemePlexes; ++i){
			for (var j = 0; j < this.mutPerGen; ++j){
				var fitness = Fitness(this.dividedFrogs[i], this.Problem);
				var best = GetBestFitness(fitness);
				var worst = GetWorstFitness(fitness);
				var newFrog = GenerateFrog(this.dividedFrogs[i][best], this.dividedFrogs[i][worst], this.bound);
				var tempWorstTrail = this.dividedFrogs[i][worst];
				var tempDist = this.Problem.getScore(newFrog);
				// If its a new global best, replace it
				if(tempDist < this.bestLength){
					this.dividedFrogs[i][worst] = newFrog;
					this.bestLength = tempDist;
					this.bestFrog = newFrog.slice(0); 
				}
				else if(tempDist < this.Problem.getScore(tempWorstTrail)){
					this.dividedFrogs[i][worst] = newFrog;
				}
				else{ // repeat above steps but using global best
					newFrog = GenerateFrog(this.bestFrog, this.dividedFrogs[i][worst], this.bound);
					var tempDist = this.Problem.getScore(newFrog);
					// If its a new global best, replace it
					if(tempDist < this.bestLength){
						this.dividedFrogs[i][worst] = newFrog;
						this.bestLength = tempDist;
						this.bestFrog = newFrog.slice(0);
					}
					else if(tempDist < this.Problem.getScore(tempWorstTrail)){
						this.dividedFrogs[i][worst] = newFrog;
					}
				}
			}
		}
		ShuffleMemPlexes(this.dividedFrogs);
		return [this.bestFrog];
}

Array.prototype.contains = function(val){
   for(var k = 0; k < this.length; ++k){
      if(this[k] == val)
	     return true;
   }
   return false;
}

function GenerateFrog(best,worst, numMutation, bound){
	var subt = new Array(best.length);
	var rand = Math.random() * 2 - 1; //[-1, 1]
	for(var k = 0; k < best.length; ++k){
		subt[k] = best[k] - worst[k]; 
		subt[k] = subt[k] * rand;
		if(subt[k] < -bound)
			subt[k] = -bound;
		else if(subt[k] > bound)
			subt[k] = bound;
		subt[k] = worst[k] + subt[k]
	}
	return subt;
}

function ShuffleMemPlexes(frogArr){
	var single = new Array(frogArr.length * frogArr[0].length);
			var count = 0;
            for (var i = 0; i < frogArr.length; ++i) 
				for(var j = 0; j < frogArr[0].length; ++j){
					single[count] = frogArr[i][j];
				}

            for (var i = 0; i < single.length; ++i) // Fisher-Yates shuffle
            {
                var r = Math.floor(Math.random() * single.length);
                var tmp = single[r]; single[r] = single[i]; single[i] = tmp;
            }

    return divideFrogs(frogArr.length, single);
}

function divideFrogs(numDivisions, frogs){
	// numDivisions must divide frogs
 	// allocate memory for frogs
	var numPerDivision = Math.floor(frogs.length / numDivisions);
	var frogArr = new Array(numDivisions);
	for(var i = 0; i < numDivisions; ++i){
		frogArr[i] = new Array(numPerDivision);
	}
	// Assign frogs to respective area
	for(var i = 0; i < numDivisions; ++i){
		for(var j = 0; j < numPerDivision; ++j){
			frogArr[i][j] = frogs[i];		
		}
	}
	return frogArr;
}

function GetBestFitness(fitness){
   // get the parent with the best fitness
   var bestFit = fitness[0];
   var bestInd = 0;
   for(var i = 1; i < fitness.length; ++i){
      if(fitness[i] < bestFit){
	     bestFit = fitness[i];
		 bestInd = i;
	  }
   }
   return bestInd;
}

function GetWorstFitness(fitness){
   // get the parent with the best fitness
   var worstFit = fitness[0];
   var worstInd = 0;
   for(var i = 1; i < fitness.length; ++i){
      if(fitness[i] > worstFit){
	     worstFit = fitness[i];
		 worstInd = i;
	  }
   }
   return worstInd;
}



function Fitness(trails, problem){
	var fitness = new Array(trails.length);
	for(var i = 0; i < trails.length; ++i){
		fitness[i] = problem.getScore(trails[i]);
	}
	return fitness;
}

function swap(x, y, trail){
   var temp = trail[x];
   trail[x] = trail[y];
   trail[y] = temp;
   return trail;
}

function IndexOfTarget(trail, target){
   var temp = 0;
   for (var i = 0; i < trail.length; ++i)
   {
      if (trail[i] == target)
          return i;
   }
   return temp;
}

function InitFrogs(numFrogs, solnSize, bound){
	var frogs = new Array(numFrogs);
            for (var k = 0; k < numFrogs; ++k)
            {	
                frogs[k] = RandomTrail(solnSize, bound);
            }
    return frogs;
}

function ReplaceWorst(fitness, wolves, children){
	var ind1;
	var worst = -1;
	for(var i = 0; i < wolves.length; ++i){
		if(fitness[i] > worst){
			worst = fitness[i];
			ind1 = i;
		}
	}
	var ind2;
	worst = -1;
	for(var i = 0; i < wolves.length; ++i){
		if(fitness[i] > worst & i != ind1){
			worst = fitness[i];
			ind2 = i;
		}
	}
	wolves[ind1] = children[0];
	wolves[ind2] = children[1];
	return wolves;
}

function RandomTrail(solnSize, bound){
   var trail = new Array(solnSize);

            for (var i = 0; i < solnSize; ++i) { 
			   trail[i] = Math.random() *2 - 1; // between -1 and 1 
			} // sequential

            return trail;
}


function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
    {
         str = str + trail[i] + " ";
	}
    console.log(str);
}
	
return {Solver: FrogSolver, Params: [ {"name": "Number of Frogs",
									  "id" : "FrogParam1",
									  "type": "int",
									  "value": 18},
									 {"name": "Number of Memory Plexes",
									  "id" : "FrogParam2",
									  "type": "int",
									  "value": 3},
									 {"name": "Number of Mutations per Generation",
									  "id" : "FrogParam3",
									  "type": "int",
									  "value": 3},
									  {"name": "Frog Boundary",
									  "id" : "FrogParam4",
									  "type": "float",
									  "value": 60}
								   ]};

});
