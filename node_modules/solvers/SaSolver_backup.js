define([], function (){
function SaSolver(Problem, Parameters){
	this.numberStarts = Parameters["SaParam1"];
	this.startTemp = Parameters["SaParam2"];
	this.points = Problem.graph.vertices;
	this.numCities = this.points.length
	this.temp = new Array(this.numberStarts);
        this.convert = Problem.trailToWeightedSolution;
	for(var i = 0; i < this.numberStarts; ++i){
		this.temp[i] = this.startTemp;
	}
	this.coolRate = Parameters["SaParam3"];
	this.dists = MakeGraphDistances(this.numCities, this.points);
	this.currentSol = new Array(this.numberStarts);
	for(var i = 0; i <  this.numberStarts; ++i)
		this.currentSol[i] = RandomTrail(Math.floor(Math.random() * this.numCities), this.numCities);
	this.bestSol = this.currentSol[0].slice(0);
	this.bestLength = Number.MAX_VALUE;
	for(var i = 0; i <  this.numberStarts; ++i){
		var tempLength = Length(this.currentSol[i], this.dists); 
		if(tempLength < this.bestLength){
			this.bestLength = tempLength;
			this.bestSol = this.currentSol[i].slice(0);
		}
	}
}

SaSolver.prototype.step = function(){
	for(var i = 0; i < this.numberStarts; ++i){
		var newSol = this.currentSol[i].slice(0);
		var tourPos1 = Math.floor(Math.random() * this.numCities);
		var tourPos2 = Math.floor(Math.random() * this.numCities);
		var ind1 = newSol.indexOf(tourPos1);
		var ind2 = newSol.indexOf(tourPos2);
		newSol = swap(ind1, ind2, newSol);
		var currentEnergy = Length(this.currentSol[i], this.dists);
		var neighborEnergy = Length(newSol, this.dists);
		if(acceptanceProb(currentEnergy, neighborEnergy, this.temp[i]) > Math.random()){
			this.currentSol[i] = newSol.slice(0);
		}
		var tempDist = Length(this.bestSol,this.dists);
		if(Length(this.currentSol[i], this.dists) < Length(this.bestSol,this.dists)){
			this.bestSol = this.currentSol[i].slice(0);
			this.bestLength = tempDist;
			console.log(this.bestLength);
		}
		this.temp[i] = this.temp[i] * (1 - this.coolRate);
	}
	return [this.convert(this.bestSol)];
}

function acceptanceProb(energy, newEnergy, temp){
   if(newEnergy < energy)
      return 1.0;
   return Math.exp((energy - newEnergy) / temp);
}

function MakeGraphDistances(numCities, points){
   var dists = new Array(numCities);
            for (var i = 0; i < dists.length; ++i){
                dists[i] = new Array(numCities);
                        }
            for (var i = 0; i < numCities; ++i){
                for (var j = i + 1; j < numCities; ++j)
                {
                    var d = cityDist(points[i], points[j]);
                    dists[i][j] = d;
                    dists[j][i] = d;
                }
                        }
  return dists;
}

function cityDist(cityX, cityY){
   return Math.sqrt(Math.pow((cityX.x - cityY.x),2) + Math.pow((cityX.y - cityY.y),2));
}


function swap(x, y, trail){
   var temp = trail[x];
   trail[x] = trail[y];
   trail[y] = temp;
   return trail;
}

function IndexOfTarget(trail, target){
   var temp = 0;
   for (var i = 0; i < trail.length; ++i)
   {
      if (trail[i] == target)
          return i;
   }
   return temp;
}

function RandomTrail(start, numCities){
   var trail = new Array(numCities);

            for (var i = 0; i < numCities; ++i) { trail[i] = i; } // sequential

            for (var i = 0; i < numCities; ++i) // Fisher-Yates shuffle
            {
                var r = Math.floor(Math.random() * (numCities- 1));
                var tmp = trail[r]; trail[r] = trail[i]; trail[i] = tmp;
            }

            var idx = IndexOfTarget(trail, start); // put start at [0]
            var temp = trail[0];
            trail[0] = trail[idx];
            trail[idx] = temp;

            return trail;
}

function initStarts(starts, numCities){
	var arr = new Array(starts);
	for(var i = 0; i < starts; ++i){
		arr[i] = RandomTrail(Math.floor(Math.random()*numCities), numCities);
	}
	return arr;
}

function BestTrail(ants, dists) // best trail has shortest total length
{
       var bestLength = Length(ants[0], dists);
       var idxBestLength = 0;
       for (var k = 1; k < ants.length; ++k){
           var len = Length(ants[k], dists);
           if (len < bestLength)
           {
                bestLength = len;
                idxBestLength = k;
           }
       }
       var size = ants[0].length;
       var bestTrail = ants[idxBestLength].slice();
       return bestTrail;
}

function Length(trail, dists) // total length of a trail
{
     var result = 0.0;
     for (var i = 0; i < trail.length - 1; ++i)
         result = result + Distance(trail[i], trail[i + 1], dists);
     result = result + Distance(trail[i], trail[0], dists);
     return result;
}

function Distance(city1, city2, dists){
   return dists[city1][city2];
}

function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
    {
         str = str + trail[i] + " ";
	}
    console.log(str);
}

return {Solver: SaSolver, Params: [ {"name": "Number of Anealing Particles",
									  "id" : "SaParam1",
									  "type": "int",
									  "value": 30},
									 {"name": "Starting Temperature",
									  "id" : "SaParam2",
									  "type": "int",
									  "value": 10000000},
									 {"name": "Cooling Rate",
									  "id" : "SaParam3",
									  "type": "double",
									  "value": 0.001}
								   ]};


});
