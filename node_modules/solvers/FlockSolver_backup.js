define([], function () {
function FlockSolver(Problem, Parameters) {

		this.tooClose = Parameters["amParam1"];
		var personalWeight = Parameters["amParam2"]; 
		var groupWeight = Parameters["amParam3"];
		var popSize = Parameters["amParam4"];
		var inertiaWeight = Parameters["amParam5"];
		var size = Problem.getSolutionSize(); //size of the problem

		console.log("Initializing Flock");
		var birdPos = InitFlock(popSize, size); //current solution vectors
		var birdVel = InitFlock(popSize, size); 
		var personalBest = birdPos.slice();
		var birdScores = _.map(birdPos, function(bird){return Problem.getScore(bird);}); //current bird scores
		var birdPos = _.sortBy(birdPos, function(bird){return Problem.getScore(bird);});
		var groupBest = birdPos[0].slice();
		var predator = birdPos[_.random(1,popSize)].slice();
		var predatorVel = birdPos[_.random(1,popSize)].slice();
		var followBest = 0;
		//initialize bird score & personal best

		this.bestLength = 0;
		
		this.step = function() {
			var predConst;
			for(var i = 0; i < popSize; i++) {
				if(birdScores[i] < Problem.getScore(personalBest[i]))
					personalBest[i] = birdPos[i].slice();
				if(birdScores[i] < Problem.getScore(groupBest)) {
					groupBest = birdPos[i].slice();
					followBest = i;
			}
			
				//this updates the velocity and position
				if(tooClose(predator, birdPos[i])){
					//console.log("TOO CLOSE");
					//These two remember previous velocity
					//birdVel[i] = vecAdd(vecDiff(birdPos[i], predator), birdVel[i]);
					//birdVel[i] = vecAdd(vecScale(birdVel[i], 1.0), birdVel[i]);
					
					//These two forget velocity
					birdVel[i] = vecDiff(birdPos[i], predator);
					birdVel[i] = vecScale(birdVel[i], 1.0);
				}
				birdVel[i] = vecScale(birdVel[i], inertiaWeight);
				birdVel[i] = vecAdd(vecScale(vecScale(vecDiff(personalBest[i], birdPos[i]),Math.random()), personalWeight), birdVel[i]);
				birdVel[i] = vecAdd(vecScale(vecScale(vecDiff(groupBest, birdPos[i]),Math.random()), groupWeight), birdVel[i]);
				birdPos[i] = vecAdd(birdPos[i], birdVel[i]);
				
				birdScores[i] = Problem.getScore(birdPos[i]);
				vecClamp(birdPos[i]);
			}
			//make the predator follow the bird with the best soltn
			//best bird is birdPos[followBest]
			predatorVel = vecDiff(birdPos[followBest], predator);
			var predWeight = (.99-.6) * Math.random() + 0.6;
			predatorVel = vecScale(predatorVel, predWeight);
			predator = vecAdd(predator, predatorVel);
			vecClamp(predator);

			this.bestLength = Problem.getScore(groupBest);
			return [vecClamp(groupBest)];
		}
}

function tooClose(predator, prey) {
	var dist = 0, retBool = false;
	var diff = [];
	diff = vecDiff(predator, prey);
	for(var i = 0; i < prey.length; i++) {
		diff[i] *=  diff[i];
		dist += diff[i];
	}
	dist = Math.sqrt(dist);
	//console.log("dist: " + dist);
	//figure out a good "too close" distance
	if(dist < 2)
		retBool = true;

	return retBool;
}

function normalize(vector) {
	var norm = [];
	var sum = 0;
	for(var i = 0; i < vector.length; i++) {
		sum += vector[i];
	}
	sum = 1/sum;
	norm = vecScale(vector, sum);
	return norm;
}

function vecAdd(veca, vecb) {
	var sum = [];
	for(var i = 0; i < veca.length; i++){
		sum[i] = veca[i] + vecb[i];
	}
	return sum;
}

function vecDiff(veca, vecb) {
	var diff = [];
	for(var i = 0; i < veca.length; i++){
		diff[i] = veca[i] - vecb[i];
	}
	return diff;
}

function vecScale(veca, scalar) {
	var scaled = [];
	for(var i = 0; i < veca.length; i++){
		scaled[i] = veca[i] * scalar;
	}
	return scaled;
}

function vecClamp(vector){
	var clamped = [];
	for(var i = 0; i < vector.length; i++){
		if(vector[i] > 1)
			clamped[i] = 1;
		else if(vector[i] < 0)
			clamped[i] = 0;
		else
			clamped[i] = vector[i];
	}
	return clamped;
}

function getAverage(simplex) {
	var list_sum = _.reduce(simplex, function(a, b) {
		var sum = [];
		for(var i = 0; i < a.length; i++) {
			sum[i] = a[i] + b[i];	
		}
		return sum;
	}, _.range(simplex[0].length));
	
	var average = _.map(list_sum, function(num){return (num/simplex.length) });
	return average;	
}

function InitFlock(n, size){
	var flock = _.range(n+1);
	flock = _.map(flock, function(){
		return _.map(_.range(size), function() { 
			return Math.random();
			}); 
		});
	return flock;
}

return {Solver: FlockSolver, Params: [           
{"name": "Too Close",
	"id" : "amParam1",
	"type": "float",
	"value": 2},
{"name": "Personal Best Weight",
	"id" : "amParam2", 
	"type": "float",   
	"value": .2}, 
{"name": "Group Best Weight",
	"id" : "amParam3",
	"type": "float",
	"value": .3},    
{"name": "Inertia Weight",
	"id" : "amParam5",       
	"type": "float",
	"value": 1},            
{"name": "Population Size",
	"id" : "amParam4",       
	"type": "float",
	"value": 50},            
]
};

});
