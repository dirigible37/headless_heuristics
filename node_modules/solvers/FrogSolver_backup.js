define([], function (){
function FrogSolver(Problem, Parameters){
	this.points = Problem.graph.vertices;
	this.numCities = this.points.length;
	this.convert = Problem.trailToWeightedSolution;
	this.numFrogs = Parameters["FrogParam1"];
	this.mutPerGen = Parameters["FrogParam3"];
	this.numMemePlexes = Parameters["FrogParam2"];
	if(this.numFrogs % this.numMemePlexes != 0){
		window.alert("Frogs must be divisible by the number of divisions");
		return;
	}
	this.bound = Parameters["FrogParam4"];
	var frogs = InitFrogs(this.numFrogs, this.numCities, this.bound);
	var trails = convertWeights(frogs);
	this.dists = MakeGraphDistances(this.numCities, this.points);
	var fitness = Fitness(trails, this.dists);
	var bestInd = GetBestFitness(fitness);
	this.bestLength = fitness[bestInd];
	this.bestFrog = frogs[bestInd].slice(0);
	this.dividedFrogs = divideFrogs(this.numMemePlexes, frogs);
}

FrogSolver.prototype.step = function(){
		for(var i = 0; i < this.numMemePlexes; ++i){
			for (var j = 0; j < this.mutPerGen; ++j){
				var trails = convertWeights(this.dividedFrogs[i]);
				var fitness = Fitness(trails, this.dists);
				var best = GetBestFitness(fitness);
				var worst = GetWorstFitness(fitness);
				var newFrog = GenerateFrog(this.dividedFrogs[i][best], this.dividedFrogs[i][worst], this.bound);
				var tempTrail = weightedSolutionToTrail(newFrog);
				var tempWorstTrail = weightedSolutionToTrail(this.dividedFrogs[i][worst]);
				var tempDist = Length(tempTrail, this.dists);
				// If its a new global best, replace it
				if(tempDist < this.bestLength){
					this.dividedFrogs[i][worst] = newFrog;
					this.bestLength = tempDist;
					console.log(this.bestLength);
					this.bestFrog = newFrog.slice(0); 
				}
				else if(tempDist < Length(tempWorstTrail,this.dists)){
					this.dividedFrogs[i][worst] = newFrog;
				}
				else{ // repeat above steps but using global best
					newFrog = GenerateFrog(this.bestFrog, this.dividedFrogs[i][worst], this.bound);
			    	tempTrail = weightedSolutionToTrail(newFrog);
					var tempDist = Length(tempTrail, this.dists);
					// If its a new global best, replace it
					if(tempDist < this.bestLength){
						this.dividedFrogs[i][worst] = newFrog;
						this.bestLength = tempDist;
						this.bestFrog = newFrog.slice(0);
						console.log(this.bestLength); 
					}
					else if(tempDist < Length(tempWorstTrail,this.dists)){
						this.dividedFrogs[i][worst] = newFrog;
					}
				}
			}
		}
		ShuffleMemPlexes(this.dividedFrogs);
		return [this.convert(this.bestFrog)];
}

Array.prototype.contains = function(val){
   for(var k = 0; k < this.length; ++k){
      if(this[k] == val)
	     return true;
   }
   return false;
}

function GenerateFrog(best,worst, numMutation, bound){
	var subt = new Array(best.length);
	var rand = Math.random() * 2 - 1; //[-1, 1]
	for(var k = 0; k < best.length; ++k){
		subt[k] = best[k] - worst[k]; 
		subt[k] = subt[k] * rand;
		if(subt[k] < -bound)
			subt[k] = -bound;
		else if(subt[k] > bound)
			subt[k] = bound;
		subt[k] = worst[k] + subt[k]
	}
	return subt;
}

function ShuffleMemPlexes(frogArr){
	var single = new Array(frogArr.length * frogArr[0].length);
			var count = 0;
            for (var i = 0; i < frogArr.length; ++i) 
				for(var j = 0; j < frogArr[0].length; ++j){
					single[count] = frogArr[i][j];
				}

            for (var i = 0; i < single.length; ++i) // Fisher-Yates shuffle
            {
                var r = Math.floor(Math.random() * single.length);
                var tmp = single[r]; single[r] = single[i]; single[i] = tmp;
            }

    return divideFrogs(frogArr.length, single);
}

function divideFrogs(numDivisions, frogs){
	// numDivisions must divide frogs
 	// allocate memory for frogs
	var numPerDivision = frogs.length / numDivisions;
	var frogArr = new Array(numDivisions);
	for(var i = 0; i < numDivisions; ++i){
		frogArr[i] = new Array(numPerDivision);
	}
	// Assign frogs to respective area
	for(var i = 0; i < numDivisions; ++i){
		for(var j = 0; j < numPerDivision; ++j){
			frogArr[i][j] = frogs[i];		
		}
	}
	return frogArr;
}

function convertWeights(weights){
   var trails = new Array(weights.length);
   for(var i = 0; i < weights.length; ++i){
      trails[i] = weightedSolutionToTrail(weights[i]);
   }
   return trails;
}

var weightedSolutionToTrail = function(weightedSolution) {
        var sorted = weightedSolution.slice(0);
		sorted.sort(function SortWeight(a,b){
			if(a < b)
	          return -1;
	        if(a > b)
	          return 1;
	        return 0;
		});
		var trail = new Array(sorted.length);
		for(var i = 0; i < sorted.length; ++i){
			trail[i] = sorted.indexOf(weightedSolution[i]);
		}
		return trail;
};

function GetBestFitness(fitness){
   // get the parent with the best fitness
   var bestFit = fitness[0];
   var bestInd = 0;
   for(var i = 1; i < fitness.length; ++i){
      if(fitness[i] < bestFit){
	     bestFit = fitness[i];
		 bestInd = i;
	  }
   }
   return bestInd;
}

function GetWorstFitness(fitness){
   // get the parent with the best fitness
   var worstFit = fitness[0];
   var worstInd = 0;
   for(var i = 1; i < fitness.length; ++i){
      if(fitness[i] > worstFit){
	     worstFit = fitness[i];
		 worstInd = i;
	  }
   }
   return worstInd;
}


function MakeGraphDistances(numCities, points){
   var dists = new Array(numCities);
            for (var i = 0; i < dists.length; ++i){
                dists[i] = new Array(numCities);
                        }
            for (var i = 0; i < numCities; ++i){
                for (var j = i + 1; j < numCities; ++j)
                {
                    var d = cityDist(points[i], points[j]);
                    dists[i][j] = d;
                    dists[j][i] = d;
                }
                        }
  return dists;
}

function cityDist(cityX, cityY){
   return Math.sqrt(Math.pow((cityX.x - cityY.x),2) + Math.pow((cityX.y - cityY.y),2));
}

function Fitness(trails, dists){
	var fitness = new Array(trails.length);
	for(var i = 0; i < trails.length; ++i){
		fitness[i] = Length(trails[i], dists);
	}
	return fitness;
}

function swap(x, y, trail){
   var temp = trail[x];
   trail[x] = trail[y];
   trail[y] = temp;
   return trail;
}

function IndexOfTarget(trail, target){
   var temp = 0;
   for (var i = 0; i < trail.length; ++i)
   {
      if (trail[i] == target)
          return i;
   }
   return temp;
}

function InitFrogs(numFrogs, numCities, bound){
	var frogs = new Array(numFrogs);
            for (var k = 0; k < numFrogs; ++k)
            {	
                frogs[k] = RandomTrail(numCities, bound);
            }
    return frogs;
}

function ReplaceWorst(fitness, wolves, children){
	var ind1;
	var worst = -1;
	for(var i = 0; i < wolves.length; ++i){
		if(fitness[i] > worst){
			worst = fitness[i];
			ind1 = i;
		}
	}
	var ind2;
	worst = -1;
	for(var i = 0; i < wolves.length; ++i){
		if(fitness[i] > worst & i != ind1){
			worst = fitness[i];
			ind2 = i;
		}
	}
	wolves[ind1] = children[0];
	wolves[ind2] = children[1];
	return wolves;
}

function RandomTrail(numCities, bound){
   var trail = new Array(numCities);

            for (var i = 0; i < numCities; ++i) { 
			   trail[i] = Math.random() * (bound*2) - bound; // between -1 and 1 
			} // sequential

            return trail;
}

function BestTrail(ants, dists) // best trail has shortest total length
{
       var bestLength = Length(ants[0], dists);
       var idxBestLength = 0;
       for (var k = 1; k < ants.length; ++k){
           var len = Length(ants[k], dists);
           if (len < bestLength)
           {
                bestLength = len;
                idxBestLength = k;
           }
       }
       var size = ants[0].length;
       var bestTrail = ants[idxBestLength].slice();
       return bestTrail;
}

function Length(trail, dists) // total length of a trail
{
     var result = 0.0;
     for (var i = 0; i < trail.length - 1; ++i)
         result = result + Distance(trail[i], trail[i + 1], dists);
     result = result + Distance(trail[i], trail[0], dists);
     return result;
}

function Distance(city1, city2, dists){
   return dists[city1][city2];
}

function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
    {
         str = str + trail[i] + " ";
	}
    console.log(str);
}
	
return {Solver: FrogSolver, Params: [ {"name": "Number of Frogs",
									  "id" : "FrogParam1",
									  "type": "int",
									  "value": 40},
									 {"name": "Number of Memory Plexes",
									  "id" : "FrogParam2",
									  "type": "int",
									  "value": 4},
									 {"name": "Number of Mutations per Generation",
									  "id" : "FrogParam3",
									  "type": "int",
									  "value": 5},
									  {"name": "Frog Boundary",
									  "id" : "FrogParam4",
									  "type": "float",
									  "value": 5}
								   ]};

});
