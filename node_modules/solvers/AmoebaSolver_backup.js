define([], function () {
		function AmoebaSolver(tspProblem, Parameters)
		{

		this.n = Parameters["amParam5"];
		this.reflectionCoeff = Parameters["amParam1"]; //reflection coefficient
		this.expansionCoeff = Parameters["amParam2"]; //expasion coefficient
		this.contractionCoeff = Parameters["amParam3"]; //contraction coefficient
		this.shrinkCoeff = Parameters["amParam4"]; //shrink coefficient
		this.points = tspProblem.graph.vertices;
		this.numCities = this.points.length;
		this.convert = tspProblem.trailToWeightedSolution;

		console.log("Number of cities: " + this.numCities);
		console.log("Pop Size: " + this.n);
		console.log("Number of Possible Path: " + fact(this.numCities));

		console.log("Initializing Amoeba");
		this.amoeba = InitAmoeba(this.n, this.numCities);
		this.Problem = tspProblem;
		this.amoeba = _.sortBy(this.amoeba, function(num){return this.Problem.getScore(num)}, this);
		console.log("I made it");

		this.bestLength = 0;
		this.average = []; 
		this.reflection = [];
		this.expansion = [];
		this.contraction = [];
		this.b = new Boolean();

		//trash variables
		this.counter = 0;
		this.counter2 = 0;
		}

AmoebaSolver.prototype.step = function(){

	this.score0=this.Problem.getScore(this.amoeba[0]);
	this.scoreN=this.Problem.getScore(this.amoeba[this.n-1]);

	this.average = CenterOfMass(this.amoeba, this.numCities, this.n);
	// Reflect the worst point over 'average'
	this.reflection = ExtensionRay(this.amoeba[this.n-1], this.average, this.reflectionCoeff*(1+this.reflectionCoeff), 1/(1+this.reflectionCoeff), this.numCities, this.n);

	if(this.score0 < this.Problem.getScore(this.reflection) && this.Problem.getScore(this.reflection) < this.scoreN)
	{
		this.amoeba[this.n-1] = this.reflection;
	}
	else
	{
		if(this.Problem.getScore(this.reflection) < this.Problem.getScore(this.amoeba[0]))
		{
			//Expand
			this.expansion = ExtensionRay(this.average, this.reflection, 1/this.expansionCoeff, (this.expansionCoeff-1)/this.expansionCoeff);

			if(this.Problem.getScore(this.expansion) < this.Problem.getScore(this.reflection))
				this.amoeba[this.n-1] = this.expansion;
			else
				this.amoeba[this.n-1] = this.reflection;
			console.log(" got past expansion ");
		}
		else
		{ 
			this.b = true;
			if(this.Problem.getScore(this.reflection) >= this.Problem.getScore(this.amoeba[this.n-1]))
			{
				//Contract: Choose a test point between r and m
				this.contraction = ConvexCombo(this.reflection, this.average, this.contractionCoeff, (1-this.contractionCoeff));

				if(this.Problem.getScore(this.contraction) <= this.Problem.getScore(this.reflection))
				{
					this.amoeba[this.n-1] = this.contraction;
					this.b = false;
				}
			}

			if(this.b == true)
			{
				//srhink
				for(var i=this.n-1;i>0;i--)
				{
					this.amoeba[i] = ConvexCombo(this.amoeba[0], this.amoeba[i], (1-this.shrinkCoeff), this.shrinkCoeff);
				}
			}
		}
	}
	//sort amoeba by scores
	this.amoeba = _.sortBy(this.amoeba, function(num){return this.Problem.getScore(num)}, this);
	this.bestLength = this.Problem.getScore(this.amoeba[0]); 

	return [this.amoeba[0]];
}

function SwapDistance(trail, trail1, numCities)
{
	var dist = 0;
	var j = 0;
	var temp = 0;
	for(var i=0; i<numCities; i++)
	{
		if(trail[i] != trail1[i])
		{
			while(trail1[j] != trail[i])
			{
				j++;
			}
			temp = trail[j];
			trail1[j] = trail[i];
			trail[i] = temp;
		}
		dist++;
		j = 0;
	}
	return dist;
}

function ExtensionRay(trailA, trailB, wAB, wBC, numCities, n)
{
	var trailC = []; 
	var j = 0;
	var distAB = SwapDistance(trailA, trailB, numCities);
	var distBC = distAB * (wAB/wBC);
	var p = distBC/(n - 1 - distAB);

	trailC = trailB.slice();
	for(var i=0; i<numCities; i++)
	{
		if(trailC[i] == trailA[i] && Math.random() <= p)
		{
			j = _.random(0,numCities-1);
			var temp = trailC[j];
			trailC[j] = trailC[i];
			trailC[i] = temp;
		}
	}
	return trailC;
}

function ConvexCombo(trailA, trailB, wA, wB)
{
	//	console.log("Convex Combo");
	trailA = trailA.slice();
	var m = Filler(0,1,wA,wB,trailA.length);
	var j = 0;
	for(var i; i < trailA.length; i++)
	{
		if(trailA[i] != trailB[i])
		{
			if(m[i] == a)
			{
				while(trailA[i] != trailB[j])
				{
					j++;
				}
				temp = trailB[j];
				trailB[j] = trailB[i];
				trailB[i] = temp;
			}
			else
			{
				while(trailB[i] != trailA[j])
				{
					j++;
				}
				temp = trailA[j];
				trailA[j] = trailA[i];
				trailA[i] = temp;
			}
			j = 0;
		}
	}
	return trailA;
}

//fills an array with either a or b depending on weights
function Filler(a, b, wA, wB, n){
	//	console.log("Filling");
	var trail = [n], rand;
	for(var i=0; i<trail.length; i++)
	{
		rand = Math.random();
		if(rand<wA)
			trail[i] = a;
		else
			trail[i] = b;
	}
	return trail;
}

function CenterOfMass(amoeba, numCities, n){
	var parents = [];
	parents = amoeba.slice();
	for(var w = 0; w < n; w++)
	{
		parents[w] = amoeba[w].slice();
	}
	var city, mostFreq = 0, posMax = 0, k=0;
	var mostPop;
	var freqMax;
	var popular = [];
	var mfe = [];
	var mfeFreq = [];
	var considered = [];
	//	console.log("Center of Mass");
	var considered = InitFalse(numCities);
	for(var j=0; j<numCities; j++)
	{
		//fill "popular" with 0's
		popular = InitZero(n, numCities);
		city = 0;
		for(var i=0; i < n; i++)
		{
			city = parents[i][j];
			popular[city]++;
		}
		//while the city has been considered, find one that hasn't
		while(considered[_.indexOf(popular,_.max(popular))] == true)
		{
			popular[_.indexOf(popular,_.max(popular))] = -1;
		}
		//find most frequently occurring element and its frequency
		mfeFreq[j] = _.max(popular);
		mfe[j] =_.indexOf(popular,_.max(popular));
		considered[mfe[j]] = true;
	}
	k = 0;
	considered = InitFalse(numCities);
	//fills the array with the most frequently occurring city at each element
	while(k < numCities)
	{
		while(considered[_.indexOf(mfe,mostFreq)] == true)
		{
			mfe[_.indexOf(mfe,_.max(mfe))] = -1;
		}
		mostFreq = _.max(mfe);
		posMax = _.indexOf(mfe,mostFreq);  
		for(j = 0; j < n; j++)
		{
			parents[j][posMax] = mostFreq;
		}
		considered[posMax] = true;
		k++;
	}
	return _.map(parents[0], function(thing) { return thing/numCities });
}

function InitAmoeba(n, numCities){
	var amoeba = [];
	var trail = [];
	for(var i = 0; i < numCities; ++i) 
	{ 
		trail[i] = i/numCities;
	}
	for(var k = 0; k < n; ++k)
	{
		amoeba[k] = _.shuffle(trail);
	}
	return amoeba;
}

function InitZero(n, numCities){
	var amoeba = [];
	for (var k = 0; k < numCities; ++k)
	{
		amoeba[k] = 0; 
	}
	return amoeba;
}

function InitFalse(numCities){
	var thisArray = [];
	for(var i = 0; i < numCities; i++){
		thisArray[i] = false;
	}
	return thisArray;
}

function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
	{
		str = str + trail[i] + " ";
	}
	console.log(str);
}

function fact(cities){
	if(cities == 1)
		return 1;
	else return cities * fact(cities - 1);
}

function IndexOfTarget(trail, target){
	var temp = 0;
	for (var i = 0; i < trail.length; ++i)
	{
		if (trail[i] == target)
			return i;
	}
	return temp;
}

return {Solver: AmoebaSolver, Params: [           
{"name": "Reflection Coefficient",
	"id" : "amParam1",
	"type": "float",
	"value": 1},
{"name": "Expansion Rate",
	"id" : "amParam2", 
	"type": "float",   
	"value": 2}, 
{"name": "Contraction Rate",
	"id" : "amParam3",
	"type": "float",
	"value": 0.8},    
{"name": "Shrink Rate",
	"id" : "amParam4",       
	"type": "float",
	"value": 0.9},            
{"name": "Population",
	"id" : "amParam5",       
	"type": "float",
	"value": 500},            
]
};

});
