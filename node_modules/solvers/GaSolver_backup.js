define([], function (){
function GaSolver(Problem, Parameters){
	this.numGenes = Parameters["GaParam1"];
	this.points = Problem.graph.vertices;
	this.numCities = this.points.length;
	this.crossRate = Parameters["GaParam2"];
	this.mutationRate = Parameters["GaParam3"];
        this.convert = Problem.trailToWeightedSolution;
	console.log("Number of cities: " + this.numCities);
	//console.log("Number of Possible Path: " + fact(this.numCities));
	console.log("Number of Genes: " + this.numGenes);
	
	console.log("Creating Points");  
	this.dists = MakeGraphDistances(this.numCities, this.points);
	
	console.log("Initializing Genes");
	this.genes = InitGenes(this.numGenes, this.numCities);
	this.fitness = Fitness(this.genes, this.dists);
	this.bestLength = 1000000;
}
GaSolver.prototype.step = function(){
	 this.genes.sort(SortGenes(this.dists));
	 this.genes = SelectParents(this.fitness, this.genes);
 	 this.genes = Crossover(this.genes, this.crossRate);
         this.genes = Mutate(this.genes, this.mutationRate);
         this.fitness = Fitness(this.genes, this.dists);
	 var ind = GetBestFitness(this.fitness, this.genes);
         this.bestLength = Length(this.genes[ind], this.dists)
	 //console.log("Best Distance on Iteration Is " + Length(this.genes[ind], this.dists));
 	 return [this.convert(this.genes[ind])];
}

function GetBestFitness(fitness, genes){
   // get the parent with the best fitness
   var bestFit = fitness[0];
   var bestInd = 0;
   for(var i = 1; i < fitness.length; ++i){
      if(fitness[i] < bestFit){
	     bestFit = fitness[i];
		 bestInd = i;
	  }
   }
   return bestInd;
}

function SortGenes(dists){
   return function(a,b){
	   if(Length(a, dists) < Length(b, dists))
	      return 1;
	   if(Length(a, dists) > Length(b, dists))
	      return -1;
	   return 0;
   }
}

function SelectParents(fitness, genes, dists){
   // Setting initial 2 parents to the best fit gene
   var selection = new Array();
   // Roullete Style Selection
   var sum = 0.0;
   
   for(var i = 0; i < fitness.length; i++){
      sum = sum + fitness[i];
   }
   var relFitness = new Array();
   for(var j = 0; j < fitness.length; j++){
      relFitness.push(fitness[j] / sum);
   }
   var prob = new Array(fitness.length);
   prob[0] = relFitness[0];
   for(var i = 1; i < fitness.length; ++i){
      prob[i] = prob[i - 1] + relFitness[i];
   }
   var count = 0;
   while(count < genes.length){
	  var n = Math.random();
	  for(var i = 0; i < genes.length; ++i){
		  if(n <= prob[i] && count < genes.length){
			  selection.push(genes[i]);
			  count++;
		  }
	  }
   }
   return selection;
}

function compare(gene1, gene2, dists){
   if(Length(gene1, dists) < Length(gene2, dists))
      return -1;
   if(Length(gene1, dists) > Length(gene2, dists))
      return 1;
   return 0;
}

function Crossover(population, crossRate){
   for(var i = 0; i < population.length - 1; i = i + 2){
      if(Math.random() < crossRate){
	       var ind1 = Math.floor(Math.random() * (population[i].length - 1));
	       var ind2 = Math.floor(Math.random() * (population[i].length - 1));
		   if(ind1 < ind2){
			   var Parent1 = population[i].slice();
			   var Parent2 = population[i + 1].slice();
			   var child1 = new Array(population[i].length);
			   var child2 = new Array(population[i].length);
			   for(var k = 0; k < child1.length; ++k){
			      child1[k] = -1; 
				  child2[k] = -1;
			   }
			   for(var k = ind1; k <= ind2; ++k){
				   child1[k] = Parent1[k];
				   child2[k] = Parent2[k];
			   }
			   for(var k = 0; k < child1.length; ++k){
				   if(!child1.contains(Parent2[k])){
					   var tInd = 0;
				       while(child1[tInd] != -1)
					      ++tInd;
					   child1[tInd] = Parent2[k]
				   }
				   if(!child2.contains(Parent1[k])){
					   var tInd = 0;
				       while(child2[tInd] != -1)
					      ++tInd;
					   child2[tInd] = Parent1[k]
				   }
			   }
			   population[i] = child1;
			   population[i + 1] = child2;
		   }
		   else{
			   var Parent1 = population[i].slice();
			   var Parent2 = population[i + 1].slice();
			   var child1 = new Array(population[i].length);
			   var child2 = new Array(population[i].length);
			   for(var k = 0; k < child1.length; ++k){
			      child1[k] = -1; 
				  child2[k] = -1;
			   }
			   for(var k = ind2; k <= ind1; ++k){
				   child1[k] = Parent1[k];
				   child2[k] = Parent2[k];
			   }
			   for(var k = 0; k < child1.length; ++k){
				   if(!child1.contains(Parent2[k])){
					   var tInd = 0;
				       while(child1[tInd] != -1)
					      ++tInd;
					   child1[tInd] = Parent2[k]
				   }
				   if(!child2.contains(Parent1[k])){
					   var tInd = 0;
				       while(child2[tInd] != -1)
					      ++tInd;
					   child2[tInd] = Parent1[k]
				   }
			   }
			   population[i] = child1;
			   population[i + 1] = child2;
		   }
	  }
   }
   return population;
}

Array.prototype.contains = function(val){
   for(var k = 0; k < this.length; ++k){
      if(this[k] == val)
	     return true;
   }
   return false;
}

function Mutate(selection, rate){
   var mutation = new Array(selection.length);
   for(var i = 0; i < selection.length; i++){ 
      var N = Math.random();
	  if(N < rate){
         var ind1 = Math.floor(Math.random() * (selection[i].length - 1));
	     var ind2 = Math.floor(Math.random() * (selection[i].length - 1));
	     if(ind1 < ind2){
		     mutation[i] = Reverse(ind1, ind2, selection[i].length, selection[i]);
	     }
	     else
	        mutation[i] = Reverse(ind2, ind1, selection[i].length, selection[i]);
	  }
	  else
	     mutation[i] = selection[i];
   }
   return mutation;
}

function Reverse(start, end, numCities, trail){
   while(start != end){
      trail = swap(start, end, trail);
      end--;
      if(end == start) 
        return trail;
      start++;
      if(end == -1)
         end = numCities - 1;
      if(start == numCities)
         start = 0;
   }
   return trail;
}

function swap(x, y, trail){
   var temp = trail[x];
   trail[x] = trail[y];
   trail[y] = temp;
   return trail;
}

function MakeGraphDistances(numCities, points){
   var dists = new Array(numCities);
            for (var i = 0; i < dists.length; ++i){
                dists[i] = new Array(numCities);
			}
            for (var i = 0; i < numCities; ++i){
                for (var j = i + 1; j < numCities; ++j)
                {
                    var d = cityDist(points[i], points[j]);
                    dists[i][j] = d;
                    dists[j][i] = d;
                }
			}
  return dists;
}

function cityDist(cityX, cityY){
   return Math.sqrt(Math.pow((cityX.x - cityY.x),2) + Math.pow((cityX.y - cityY.y),2));
}

function InitGenes(numGenes, numCities){
	var genes = new Array(numGenes);
            for (var k = 0; k < numGenes; ++k)
            {
			    // Generates Random Starting City for each ant	
                var start = Math.floor(Math.random() * (numCities - 1));
                genes[k] = RandomTrail(start, numCities);
            }
    return genes;
}


function RandomTrail(start, numCities){
   var trail = new Array(numCities);

            for (var i = 0; i < numCities; ++i) { trail[i] = i; } // sequential

            for (var i = 0; i < numCities; ++i) // Fisher-Yates shuffle
            {
                var r = Math.floor(Math.random() * (numCities- 1));
                var tmp = trail[r]; trail[r] = trail[i]; trail[i] = tmp;
            }

            var idx = IndexOfTarget(trail, start); // put start at [0]
            var temp = trail[0];
            trail[0] = trail[idx];
            trail[idx] = temp;

            return trail;
}

function IndexOfTarget(trail, target){
   var temp = 0;
   for (var i = 0; i < trail.length; ++i)
   {
      if (trail[i] == target)
          return i;
   }
   return temp;
}

function Fitness(genes, dists){
	var fitness = new Array(genes.length);
	for(var i = 0; i < genes.length; i++){
	   fitness[i] = Length(genes[i], dists);
	}
	return fitness;
}

function BestTrail(ants, dists) // best trail has shortest total length
{
       var bestLength = Length(ants[0], dists);
       var idxBestLength = 0;
       for (var k = 1; k < ants.length; ++k){
           var len = Length(ants[k], dists);
           if (len < bestLength)
           {
                bestLength = len;
                idxBestLength = k;
           }
       }
       var size = ants[0].length;
       var bestTrail = ants[idxBestLength].slice();
       return bestTrail;
}

function Length(trail, dists) // total length of a trail
{
     var result = 0.0;
     for (var i = 0; i < trail.length - 1; ++i)
         result = result + Distance(trail[i], trail[i + 1], dists);
     result = result + Distance(trail[i], trail[0], dists);
     return result;
}

function Distance(city1, city2, dists){
   return dists[city1][city2];
}


function EdgeInTrail(cityX, cityY, trail)
{
            // are cityX and cityY adjacent to each other in trail[]?
            var lastIndex = trail.length - 1;
            var idx = IndexOfTarget(trail, cityX);

            if (idx == 0 && trail[1] == cityY) return true;
            else if (idx == 0 && trail[lastIndex] == cityY) return true;
            else if (idx == 0) return false;
            else if (idx == lastIndex && trail[lastIndex - 1] == cityY) return true;
            else if (idx == lastIndex && trail[0] == cityY) return true;
            else if (idx == lastIndex) return false;
            else if (trail[idx - 1] == cityY) return true;
            else if (trail[idx + 1] == cityY) return true;
            else return false;
}

function BuildTrail(k, start, pheromones, dists, alpha, beta){
            var numCities = pheromones.length;
            var trail = new Array(numCities);
            var visited = new Array(numCities);
            trail[0] = start;
            visited[start] = true;
            for (var i = 0; i < numCities - 1; ++i)
            {
                var cityX = trail[i];
                var next = NextCity(k, cityX, visited, pheromones, dists, alpha, beta);
                trail[i + 1] = next;
                visited[next] = true;
            }
            return trail;
}



function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
    {
         str = str + trail[i] + " ";
	}
    console.log(str);
}

return {Solver: GaSolver,
			Params: [                 {"name": "Number of Genes",
                                                        "id" : "GaParam1",
                                                        "type": "int",
                                                        "value": 50},   
                                                  {"name": "Crossover Rate",
                                                        "id" : "GaParam2",
                                                        "type": "float",
                                                        "value": 0.8},
                                                  {"name": "Mutation Rate",
                                                        "id" : "GaParam3",
                                                        "type": "float",
                                                        "value": 0.1}      
                                                ]                       
                        }; 

});
