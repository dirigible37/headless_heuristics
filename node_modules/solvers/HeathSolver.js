define([], function (){
function FireFlySolver(Problem, Parameters){
	this.points = Problem.graph.vertices;
	this.numCities = this.points.length
	this.numfireflies = Parameters["FireFlyParam1"]; // 8
	this.replaceRate = Parameters["FireFlyParam2"] // 40
	this.curRep = -1;
	this.fireflies = Initfireflies(this.numfireflies, this.numCities);
	this.dists = MakeGraphDistances(this.numCities, this.points);
	this.fitness = Fitness(this.fireflies, this.dists);
	this.convert = Problem.trailToWeightedSolution;
	this.Leaders = new Array(2);
	this.bestLength = Number.MAX_VALUE;
	this.Leaders[0] = this.fireflies[0].slice(0);
	this.Leaders[1] = this.fireflies[1].slice(0);
	this.bestSol = this.Leaders[0];
}

FireFlySolver.prototype.step = function(){
		var nextGen = CreateNeighborfireflies(this.fireflies, this.numCities);
		var LeaderChanged = GetLeaders(this.Leaders, nextGen, this.dists);
		var Children = Mate(this.Leaders, new Array(2));
		this.fitness = Fitness(nextGen, this.dists);
		this.fireflies = ReplaceWorst(this.fitness, nextGen, Children);
		if(LeaderChanged == 0){
			++this.curRep;
		}
		else
		    this.curRep = 0;
		if(this.curRep ==  this.replaceRate){
			var ind = this.fireflies.indexOf(Leaders[0]);
			this.Leaders[0] = this.Leaders[1].slice(0);
			this.fireflies[ind] = RandomTrail(Math.floor(Math.random() * this.fireflies[ind].length));
			this.Leaders[1] = this.fireflies[ind].slice(0);
		}
		this.fitness = Fitness(this.fireflies, this.dists);
		var tempInd = GetBestFitness(this.fitness);
		var tempDist = this.fitness[tempInd];
		if(tempDist < this.bestLength){
			this.bestLength = tempDist;
			this.bestSol = this.fireflies[tempInd].slice(0);
		}
		return [this.convert(this.bestSol)];
}

function acceptanceProb(energy, newEnergy, temp){
   if(newEnergy < energy)
      return 1.0;
   return Math.exp((energy - newEnergy) / temp);
}

Array.prototype.contains = function(val){
   for(var k = 0; k < this.length; ++k){
      if(this[k] == val)
	     return true;
   }
   return false;
}

function GetBestFitness(fitness){
   // get the parent with the best fitness
   var bestFit = fitness[0];
   var bestInd = 0;
   for(var i = 1; i < fitness.length; ++i){
      if(fitness[i] < bestFit){
	     bestFit = fitness[i];
		 bestInd = i;
	  }
   }
   return bestInd;
}

function MakeGraphDistances(numCities, points){
   var dists = new Array(numCities);
            for (var i = 0; i < dists.length; ++i){
                dists[i] = new Array(numCities);
                        }
            for (var i = 0; i < numCities; ++i){
                for (var j = i + 1; j < numCities; ++j)
                {
                    var d = cityDist(points[i], points[j]);
                    dists[i][j] = d;
                    dists[j][i] = d;
                }
                        }
  return dists;
}

function cityDist(cityX, cityY){
   return Math.sqrt(Math.pow((cityX.x - cityY.x),2) + Math.pow((cityX.y - cityY.y),2));
}
function Fitness(trails, dists){
	var fitness = new Array(trails.length);
	for(var i = 0; i < trails.length; ++i){
		fitness[i] = Length(trails[i], dists);
	}
	return fitness;
}

function swap(x, y, trail){
   var temp = trail[x];
   trail[x] = trail[y];
   trail[y] = temp;
   return trail;
}

function IndexOfTarget(trail, target){
   var temp = 0;
   for (var i = 0; i < trail.length; ++i)
   {
      if (trail[i] == target)
          return i;
   }
   return temp;
}

function Initfireflies(numfireflies, numCities){
	var ants = new Array(numfireflies);
            for (var k = 0; k < numfireflies; ++k)
            {
			    // Generates Random Starting City for each ant	
                var start = Math.floor(Math.random() * (numCities - 1));
                ants[k] = RandomTrail(start, numCities);
				
            }
    return ants;
}

function CreateNeighborfireflies(fireflies, numCities){
	    // fireflies must not be edited, aka const
        var nextGen = new Array(fireflies.length); 
		for(var i = 0; i < fireflies.length; ++i){
			// Randomly swaps one neighbor. TSP may need more mutation...
			var newSol = fireflies[i].slice(0);
			var tourPos1 = Math.floor(Math.random() * numCities);
			var tourPos2 = Math.floor(Math.random() * numCities);
			var ind1 = newSol.indexOf(tourPos1);
			var ind2 = newSol.indexOf(tourPos2);
			newSolution = swap(ind1, ind2, newSol);
			nextGen[i] = newSolution;
		}
		// return the new fireflies to test
		return nextGen;
}

// Purpose of this function is to get the two best fireflies in the new generation
function GetLeaders(currentLeaders, nextGen, dists){
	var leader1 = currentLeaders[0];
	var leader2 = currentLeaders[1];
	var leader1ind = -1;
	var leader2ind = -2;
	var leader1dist = Length(currentLeaders[0], dists);
	var leader2dist = Length(currentLeaders[1], dists);
	for(var i = 0; i < nextGen.length; ++i){
		var nextGenDist = Length(nextGen[i], dists);
		if( nextGenDist < leader1dist){
			// need to update the 2nd best to be old main leader
			leader2ind = leader1ind;
			leader2dist = leader1dist;
			leader1ind = i;
			leader1dist = nextGenDist;
			
		}
		else if(nextGenDist < leader2dist){
			leader2ind = i;
			leader2dist = nextGenDist;
		}
	}
	if(leader2ind != -2){
		if(leader2ind == -1)
		   currentLeaders[1] = leader1.slice(0);
		else
		   currentLeaders[1] = nextGen[leader2ind].slice(0);
	}
	if(leader1ind != -1){
		currentLeaders[0] = nextGen[leader1ind].slice(0);
	}
	// Need to know if leader changed;
	if(leader1ind != -1)
		return 0;
	else
		return -1;
}

function Mate(Leaders, Children){
	       var ind1 = Math.floor(Math.random() * (Leaders[0].length));
	       var ind2 = Math.floor(Math.random() * (Leaders[0].length));
		   if(ind1 < ind2){
			   var Parent1 = Leaders[0].slice();
			   var Parent2 = Leaders[1].slice();
			   var child1 = new Array(Leaders[0].length);
			   var child2 = new Array(Leaders[0].length);
			   for(var k = 0; k < child1.length; ++k){
			      child1[k] = -1; 
				  child2[k] = -1;
			   }
			   for(var k = ind1; k <= ind2; ++k){
				   child1[k] = Parent1[k];
				   child2[k] = Parent2[k];
			   }
			   for(var k = 0; k < child1.length; ++k){
				   if(!child1.contains(Parent2[k])){
					   var tInd = 0;
				       while(child1[tInd] != -1)
					      ++tInd;
					   child1[tInd] = Parent2[k]
				   }
				   if(!child2.contains(Parent1[k])){
					   var tInd = 0;
				       while(child2[tInd] != -1)
					      ++tInd;
					   child2[tInd] = Parent1[k]
				   }
			   }
			   Children[0] = child1;
			   Children[1] = child2;
		   }
		   else{
			   var Parent1 = Leaders[0].slice();
			   var Parent2 = Leaders[1].slice();
			   var child1 = new Array(Leaders[0].length);
			   var child2 = new Array(Leaders[0].length);
			   for(var k = 0; k < child1.length; ++k){
			      child1[k] = -1; 
				  child2[k] = -1;
			   }
			   for(var k = ind2; k <= ind1; ++k){
				   child1[k] = Parent1[k];
				   child2[k] = Parent2[k];
			   }
			   for(var k = 0; k < child1.length; ++k){
				   if(!child1.contains(Parent2[k])){
					   var tInd = 0;
				       while(child1[tInd] != -1)
					      ++tInd;
					   child1[tInd] = Parent2[k]
				   }
				   if(!child2.contains(Parent1[k])){
					   var tInd = 0;
				       while(child2[tInd] != -1)
					      ++tInd;
					   child2[tInd] = Parent1[k]
				   }
			   }
			   Children[0] = child1;
			   Children[1] = child2;
		   }
   return Children;
}

function ReplaceWorst(fitness, fireflies, children){
	var ind1;
	var worst = -1;
	for(var i = 0; i < fireflies.length; ++i){
		if(fitness[i] > worst){
			worst = fitness[i];
			ind1 = i;
		}
	}
	var ind2;
	worst = -1;
	for(var i = 0; i < fireflies.length; ++i){
		if(fitness[i] > worst & i != ind1){
			worst = fitness[i];
			ind2 = i;
		}
	}
	fireflies[ind1] = children[0];
	fireflies[ind2] = children[1];
	return fireflies;
}

function RandomTrail(start, numCities){
   var trail = new Array(numCities);

            for (var i = 0; i < numCities; ++i) { trail[i] = i; } // sequential

            for (var i = 0; i < numCities; ++i) // Fisher-Yates shuffle
            {
                var r = Math.floor(Math.random() * (numCities- 1));
                var tmp = trail[r]; trail[r] = trail[i]; trail[i] = tmp;
            }

            var idx = IndexOfTarget(trail, start); // put start at [0]
            var temp = trail[0];
            trail[0] = trail[idx];
            trail[idx] = temp;

            return trail;
}

function BestTrail(ants, dists) // best trail has shortest total length
{
       var bestLength = Length(ants[0], dists);
       var idxBestLength = 0;
       for (var k = 1; k < ants.length; ++k){
           var len = Length(ants[k], dists);
           if (len < bestLength)
           {
                bestLength = len;
                idxBestLength = k;
           }
       }
       var size = ants[0].length;
       var bestTrail = ants[idxBestLength].slice();
       return bestTrail;
}

function Length(trail, dists) // total length of a trail
{
     var result = 0.0;
     for (var i = 0; i < trail.length - 1; ++i)
         result = result + Distance(trail[i], trail[i + 1], dists);
     result = result + Distance(trail[i], trail[0], dists);
     return result;
}

function Distance(city1, city2, dists){
   return dists[city1][city2];
}

function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
    {
         str = str + trail[i] + " ";
	}
    console.log(str);
}

return {Solver: HeathSolver, Params: [ {"name": "Number of FireFlies",
									  "id" : "FireFlyParam1",
									  "type": "int",
									  "value": 8},
									 {"name": "Replacement Rate",
									  "id" : "FireFlyParam2",
									  "type": "int",
									  "value": 50}
								   ]};

});
