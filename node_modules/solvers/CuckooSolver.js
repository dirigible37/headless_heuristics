define([], function () {
		function BaseSolver(Problem, Parameters) {

		//You can change the variable names, but these are parameters the user can set
		var discoveryProb = Number(Parameters["cuckooParam1"]); // [0, 1].  likelyhood a non-native egg is discovered
		var eggsPerNest = Parameters["cuckooParam2"]; // This value will most likely always remain at one unelss we want to extend the algorithm
		var numHostNests = Parameters["cuckooParam3"]; // available nests for cuckoo birds to place their eggs
		var size = Problem.getSolutionSize();
		var solutionVec = initEggs(numHostNests, size);
		solutionVec = _.sortBy(solutionVec, function(egg){return Problem.getScore(egg);});
		var eggScores = _.map(solutionVec, function(egg){return Problem.getScore(egg);});
		//use this to get the score of your solution vector
		//      Problem.getScore(/*vector*/I);
		var count = 0;
		
		this.bestLength = Number.MAX_VALUE;
		var curBestScore = 0;
		var curBestSoln = solutionVec[0];
		var totalBestSoln = solutionVec[0];

		this.step = function() {
			var replaceCount = 0;
			var levyCount = 0;
			var randomCount = 0;
			var direction;
			var stepLength;                
			var walkFrom = _.first(solutionVec);
			//get rid of bad solutions
			for(var i = 0; i < (eggScores.length - 1); i++) {
				if(discoveryChance(discoveryProb, eggScores[i]) === -1) {
					//Levy
					if(Math.random() <= 0.8) {
						stepLength = genLevy(2);
						direction = genDirection(size);
						walkFrom = _.first(solutionVec);
						count++;
						solutionVec[i] = vecAdd(walkFrom, vecScale(direction, stepLength));
						//console.log(solutionVec[i]);
					}
					//random
					else {
						solutionVec[i] = RandomTrail(size); 
					}
				}
			}
			
			solutionVec = _.sortBy(solutionVec, function(egg){return Problem.getScore(egg);});
			eggScores = _.map(solutionVec, function(egg){return Problem.getScore(egg);});
			
			curBestScore = eggScores[0];
			curBestSoln = solutionVec[0];
			if(curBestScore < this.bestLength) { 
				this.bestLength = curBestScore;
				totalBestSoln = curBestSoln;
			}
			//return vector of weights (the best solution you have)
			this.bestLength = Problem.getScore(totalBestSoln);
			return [totalBestSoln];
			}
		}
		/***********************************************************************************/
		/********** I've provided you with some basic vector operation functions ***********/
		/********************* If you have questions, feel free to ask *********************/

		function RandomTrail(probSize){
			var trail = new Array(probSize);
			for(var i = 0; i < probSize; i++) {
				trail[i] = Math.random();
			}
			return trail;
		}

		function getMagnitude(vector) {
			var magnitude = 0;
			for(var i = 0; i < vector.length; i++) {
				magnitude += Math.pow(vector[i], 2);
			}
			magnitude = Math.sqrt(magnitude)
				return magnitude;
		}

		function normalize(vector) {
			var magnitude = getMagnitude(vector);
			for(var i = 0; i < vector.length; i++) {
				vector[i] = vector[i] / magnitude;
			}
			return vector;
		}

		function vecAdd(veca, vecb) {
			var sum = [];
			for(var i = 0; i < veca.length; i++){
				sum[i] = veca[i] + vecb[i];
			}
			return sum;
		}

		function vecDiff(veca, vecb) {
			var diff = [];
			for(var i = 0; i < veca.length; i++){
				diff[i] = veca[i] - vecb[i];
			}
			return diff;
		}

		function vecScale(veca, scalar) {
			var scaled = [];
			for(var i = 0; i < veca.length; i++){
				scaled[i] = veca[i] * scalar;
			}
			return scaled;
		}

		function initEggs(n, size) {
			var solutionVec = _.range(n);
			solutionVec = _.map(solutionVec, function(){
					return _.map(_.range(size), function() {
						return Math.random();
						});
					});
			return solutionVec;
		}

		//Clamps the weights to all being between 0 and 1. Do this before you
		//return your vector, the scoring function likes it like that.
		function vecClamp(vector){
			var clamped = [];
			for(var i = 0; i < vector.length; i++){
				if(vector[i] > 1)
					clamped[i] = 1;
				else if(vector[i] < 0)
					clamped[i] = 0;
				else
					clamped[i] = vector[i];
			}
			return clamped;
		}

		function genDirection(size) {
			var direction = [];
			for(var i = 0; i < size; i++) {
				direction[i] = Math.random(-1, 1);
			}
			direction = normalize(direction);
			return direction;
		}

		function genGaussian(stdDeviation) {

			var result = _.random((-100, 100) + _.random(-100, 100) + _.random(-100, 100)) / 100;
			result = result * stdDeviation;
			return result;
		}

		function genLevy(scaleFactor) {

			var variance = Math.sqrt(1 / 2 * scaleFactor);
			//      console.log("v = " + variance);
			var gaussian = genGaussian(Math.sqrt(variance));
			//console.log("gaussian = " + gaussian);
			var levyNumber = 1 / Math.pow(gaussian, 2);
			//console.log("levy = " + levyNumber);  
			return levyNumber;
		}

		function discoveryChance(weight, score) {

			// THE VALUE '15' HERE IS A [POORLY] GUESSED TEMP VALUE TO BE CHANGED AS A "MEDIAN" SORTA SCORE
			var weightedChance = weight + 5;
			var weightedChance = (weightedChance * ((score - 15)/100));
			if((_.random(0, 100) / 100) > weightedChance) {
				return -1; // The egg has been found!
			} else {
				return 1; // the egg is safe... for now.
			}
		}

		return {Solver: BaseSolver, Params: [

			//These are user-editable parameters
			//feel free to change the name and starting values of them
			//also feel free to add as many as you feel you need.
			{"name": "Detection Chance",
				"id" : "cuckooParam1",
				"type": "float",
				"value": 0.54},
				{"name": "Eggs per nest",
					"id" : "cuckooParam2",
					"type" : "int",
					"value" : 2},
				{"name": "Nests Available",
					"id" : "cuckooParam3",
					"type": "int",
					"value": 19},
				]
		};

});
