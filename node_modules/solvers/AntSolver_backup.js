define([], function () {
function AntSolver(Problem, Parameters){
	this.numAnts = Parameters["antParam1"]; 
	this.alpha = Parameters["antParam2"]; // Pheremone influence
	this.beta = Parameters["antParam3"];  // local node influence
	this.rho = Parameters["antParam4"]; // pheremone evaporation rate
	this.Q = Parameters["antParam5"];  // pheromone deposit factor
        this.problem = Problem;
	this.points = Problem.graph.vertices;
	this.numCities = this.points.length;
	this.convert = Problem.trailToWeightedSolution;
	console.log("Number of cities: " + this.numCities);
	console.log("Number of Possible Path: " + fact(this.numCities));
	console.log("Number of ants: " + this.numAnts);
	console.log("Alpha (pheremone influence): " + this.alpha);
	console.log("Beta (local node influence): " + this.beta);
	console.log("Rho (pheremone evaporation coeffiecient): " + this.rho);
	console.log("Q (pheremone deposit factor): " + this.Q);	
	
	console.log("Calculating Distances");
	this.dists = MakeGraphDistances(this.numCities, this.points);
	
	console.log("Initializing Ants");
	this.ants = InitAnts(this.numAnts, this.numCities);
	this.bestTrail = BestTrail(this.ants, this.dists);
	this.bestLength = Length(this.bestTrail, this.dists);
	console.log("Best initial trial Length: " + this.bestLength);
	console.log("Initializing Pheromones on trails");
	this.pheromones = InitPheromones(this.numCities);
}

AntSolver.prototype.step = function(){
	 UpdateAnts(this.ants, this.pheromones, this.dists, this.alpha, this.beta);
         UpdatePheromones(this.pheromones, this.ants, this.dists, this.rho, this.Q);

         var currBestTrail = BestTrail(this.ants, this.dists);
         var currBestLength = Length(currBestTrail, this.dists);
         if (currBestLength < this.bestLength)
         {
            this.bestLength = currBestLength;
            this.bestTrail = currBestTrail;
         }
   	
    return [this.convert(this.bestTrail)];
}

function MakeGraphDistances(numCities, points){
   var dists = new Array(numCities);
            for (var i = 0; i < dists.length; ++i){
                dists[i] = new Array(numCities);
			}
            for (var i = 0; i < numCities; ++i){
					//console.log("x: " + points[i].x*350 + " y: " + points[i].y*350);
                for (var j = i + 1; j < numCities; ++j)
                {
						
                    var d = cityDist(points[i], points[j]);
                    dists[i][j] = d;
                    dists[j][i] = d;
                }
			}
  return dists;
}

function cityDist(cityX, cityY){
   return Math.sqrt(Math.pow((cityX.x - cityY.x),2) + Math.pow((cityX.y - cityY.y),2));
}

function InitAnts(numAnts, numCities){
	var ants = new Array(numAnts);
            for (var k = 0; k < numAnts; ++k)
            {
			    // Generates Random Starting City for each ant	
                var start = Math.floor(Math.random() * (numCities - 1));
                ants[k] = RandomTrail(start, numCities);
				
            }
    return ants;
}

function RandomTrail(start, numCities){
   var trail = new Array(numCities);

            for (var i = 0; i < numCities; ++i) { trail[i] = i; } // sequential

            for (var i = 0; i < numCities; ++i) // Fisher-Yates shuffle
            {
                var r = Math.floor(Math.random() * (numCities- 1));
                var tmp = trail[r]; trail[r] = trail[i]; trail[i] = tmp;
            }

            var idx = IndexOfTarget(trail, start); // put start at [0]
            var temp = trail[0];
            trail[0] = trail[idx];
            trail[idx] = temp;

            return trail;
}

function IndexOfTarget(trail, target){
   var temp = 0;
   for (var i = 0; i < trail.length; ++i)
   {
      if (trail[i] == target)
          return i;
   }
   return temp;
}

function BestTrail(ants, dists) // best trail has shortest total length
{
       var bestLength = Length(ants[0], dists);
       var idxBestLength = 0;
       for (var k = 1; k < ants.length; ++k){
           var len = Length(ants[k], dists);
           if (len < bestLength)
           {
                bestLength = len;
                idxBestLength = k;
           }
       }
       var size = ants[0].length;
       var bestTrail = ants[idxBestLength].slice();
       return bestTrail;
}

function Length(trail, dists) // total length of a trail
{
     var result = 0.0;
     var i = 0;
     for (i = 0; i < trail.length - 1; ++i)
         result = result + Distance(trail[i], trail[i + 1], dists);
     result = result + Distance(trail[i], trail[0], dists);
     return result;
}

function Distance(city1, city2, dists){
   return dists[city1][city2];
}

function InitPheromones(numCities){
            var pheromones = new Array(numCities);
            for (var i = 0; i < numCities; ++i)
                pheromones[i] = new Array(numCities);
            for (var i = 0; i < pheromones.length; ++i)
                for (var j = 0; j < pheromones[i].length; ++j)
                    pheromones[i][j] = 0.01;
            return pheromones;
}

function UpdateAnts(ants, pheromones, dists, alpha, beta){
     var numCities = pheromones.length;
     for (var k = 0; k < ants.length; ++k)
     {
         var start = Math.floor(Math.random() * numCities);
         var newTrail = BuildTrail(k, start, pheromones, dists, alpha, beta);
         ants[k] = newTrail;
     }
}

function UpdatePheromones(pheromones, ants, dists, rho, Q){
   for (var i = 0; i < pheromones.length; ++i)
   {
      for (var j = i + 1; j < pheromones[i].length; ++j)
      {
         for (var k = 0; k < ants.length; ++k)
         {
            var length = Length(ants[k], dists); // length of ant k trail
            var decrease = (1.0 - rho) * pheromones[i][j];
            var increase = 0.0;
            if (EdgeInTrail(i, j, ants[k]) == true) increase = (Q / length);
			
            pheromones[i][j] = decrease + increase;

            if (pheromones[i][j] < 0.0001)
                pheromones[i][j] = 0.0001;
            else if (pheromones[i][j] > 100000.0)
                pheromones[i][j] = 100000.0;

            pheromones[j][i] = pheromones[i][j];
         }
      }
   }
}

function EdgeInTrail(cityX, cityY, trail)
{
            // are cityX and cityY adjacent to each other in trail[]?
            var lastIndex = trail.length - 1;
            var idx = IndexOfTarget(trail, cityX);

            if (idx == 0 && trail[1] == cityY) return true;
            else if (idx == 0 && trail[lastIndex] == cityY) return true;
            else if (idx == 0) return false;
            else if (idx == lastIndex && trail[lastIndex - 1] == cityY) return true;
            else if (idx == lastIndex && trail[0] == cityY) return true;
            else if (idx == lastIndex) return false;
            else if (trail[idx - 1] == cityY) return true;
            else if (trail[idx + 1] == cityY) return true;
            else return false;
}

function BuildTrail(k, start, pheromones, dists, alpha, beta){
            var numCities = pheromones.length;
            var trail = new Array(numCities);
            var visited = new Array(numCities);
            trail[0] = start;
            visited[start] = true;
            for (var i = 0; i < numCities - 1; ++i)
            {
                var cityX = trail[i];
                var next = NextCity(k, cityX, visited, pheromones, dists, alpha, beta);
                trail[i + 1] = next;
                visited[next] = true;
            }
            return trail;
}

function NextCity(k, cityX, visited, pheromones, dists, alpha, beta){
// for ant k (with visited[]), at nodeX, what is next node in trail?
            var probs = MoveProbs(k, cityX, visited, pheromones, dists, alpha, beta);

            var cumul = new Array(probs.length + 1);
			cumul[0] = 0.0;
            for (var i = 0; i < probs.length; ++i)
                cumul[i + 1] = cumul[i] + probs[i];

            var p = Math.random();
            var ans = 0;
            for (var i = 0; i < cumul.length - 1; ++i)
                if (p >= cumul[i] && p < cumul[i + 1])
                    return i;
				
		    return ans;
}

function MoveProbs(k, cityX, visited, pheromones, dists, alpha, beta){
// for ant k, located at nodeX, with visited[], return the prob of moving to each city
            var numCities = pheromones.length;
            var taueta = new Array(numCities); // inclues cityX and visited cities
            var sum = 0.0; // sum of all tauetas
            for (var i = 0; i < taueta.length; ++i) // i is the adjacent city
            {
                if (i == cityX)
                    taueta[i] = 0.0; // prob of moving to self is 0
                else if (visited[i] == true)
                    taueta[i] = 0.0; // prob of moving to a visited city is 0
                else
                {
                    taueta[i] = Math.pow(pheromones[cityX][i], alpha) * Math.pow((1.0 / Distance(cityX, i, dists)), beta); 
                    if (taueta[i] < 0.0001)
                        taueta[i] = 0.0001;
                    else if (taueta[i] > (Number.MAX_VALUE / (numCities * 100)))
                        taueta[i] = Number.MAX_VALUE / (numCities * 100);
                }
                sum += taueta[i];
            }

            var probs = new Array(numCities);
            for (var i = 0; i < probs.length; ++i)
                probs[i] = taueta[i] / sum;
            return probs;
}

function Display(trail){
	var str = "";
	for (var i = 0; i < trail.length; ++i)
    {
         str = str + trail[i] + " ";
	}
    console.log(str);
}

function fact(cities){
   if(cities == 1)
      return 1;
   else return cities * fact(cities - 1);
}

return {Solver: AntSolver,
			Params: [                 {"name": "Number of Ants",
							"id" : "antParam1",
							"type": "int",
							"value": 20},
						  {"name": "Pheremone Influence",
							"id" : "antParam2",
							"type": "float",
							"value": .5},
						  {"name": "Local Node Influence",
							"id" : "antParam3",
							"type": "float",
							"value": 3},
						  {"name": "Pheremone Evaporation Rate",
							"id" : "antParam4",
							"type": "float",
							"value": .1},
						  {"name": "Pheremone Deposit Factor",
							"id" : "antParam5",
							"type": "float",
							"value": 1.0}
						]
			};

});
